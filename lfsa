#!/bin/bash
#
if [ $UID -ne 0 ]; then echo Please run this script as root. ; exit 1; fi
LFS=$LFS
if [[ ! -d $LFS || "$LFS" = "" ]]; then
  echo "'$LFS' is not a directory"
  echo "do: export LFS=/mnt/lfs"
  echo
  exit 1
fi
#
# make sure there is a tools dir, and a symlink to it
if [ -e $LFS/tools -a ! -d $LFS/tools ]; then
  echo "$LFS/tools is not a directory"
  mv -v $LFS/tools $LFS/tools.backup
  echo "moved to $LFS/tools.backup"
  echo "create directory $LFS/tools"
  install -vd $LFS/tools
fi
if [ "$LFS/tools" != "$( ls -l /tools | awk '{print $NF}' )" ]; then
  echo "/tools is not a symlink to $LFS/tools"
  echo ""
  echo "as root, do:"
  echo ""
  echo " ln -s $LFS/tools /tools"
  exit 1
fi
# repository will be for LFS
REPO="LFS"
cfg=$1 # name of the config file, if present
if [ ! -z $cfg ]; then # config filename given
  if [ ! -e $cfg ]; then # doesn't exist - exit
    echo "If you give the config filename it must exist"
    echo "Exiting now"
    exit 1
  else
    display_menu=false
  fi
else
  display_menu=true
  cfg=~/LFS.conf
fi
lfscommands=lfs-commands # the dir containing the lfs-commands
lfshtml=lfs-html # the dir containing the lfs html
DumpedCommands=${LFS}/${lfscommands}
Dumpedhtml=${LFS}/${lfshtml}
wgetlist="wget-list" # name of the file containing all the source URLs
wgetopts="" # Options for wget, e.g. proxy settings etc
RETURN_PARAM=251  # return parameter from a function on error
#
# these are relative to newly installed lfs ( i.e. without $LFS prefix )
sourcedir=/sources
builddir05=/build # chapter 5 build dir
PkgUserDir=/usr/src/core # all installed packages sit under here
BuildLog=$LFS/LFS-buildlog.log # keep a record of packages and times
if [ ! -e $BuildLog ]; then
  touch $BuildLog
  chown lfs:lfs $BuildLog #make lfs the owner
fi
SOURCEDIR=${LFS}${sourcedir}
build="build" # name of the build file for each package
#initialize the config variables
TZ=$TZ
PAPER_SIZE=$PAPER_SIZE
LFS_BOOK_LOC_DIR=$HOME/LFS_SVN/$REPO # def local dir for the downloaded book xml
SVN_URL="svn://svn.linuxfromscratch.org/$REPO/" #svn url
BOOK_VERSION=$BOOK_VERSION
SOURCES=$SOURCES
CLEAN_SRC_DIR=$CLEAN_SRC_DIR
BOOK=$BOOK
WHICH_CHAPTER=$WHICH_CHAPTER
PKGUSERFILE=$PKGUSERFILE
TESTS=$TESTS
MAKE_KERNEL=$MAKE_KERNEL # "no" -  stop at make mrproper, "yes" - use a .config and make
AS_ROOT=$AS_ROOT # 'no' install as package user, 'yes' install as root
SYSTEMD=$SYSTEMD # 'yes' use systemd, 'no' use sysvinit for control
if [ -e $cfg ]; then
  source $cfg # exists so source it
else
  touch $cfg #cfg is new
  if [ -z $TZ ]; then #null
    TZ="America/Chicago"
  fi
  if [ -z $PAPER_SIZE ]; then #null
    PAPER_SIZE="letter"
  fi
  if [ -z $BOOK ]; then
    BOOK="svn"
  fi
  if [ -z $BOOK_VERSION ]; then
    BOOK_VERSION="blank"
  fi
  if [ -z $SOURCES ]; then
    SOURCES="download"
  fi
  if [ -z $CLEAN_SRC_DIR ]; then
    CLEAN_SRC_DIR="no"
  fi
  if [ -z $WHICH_CHAPTER ]; then
    WHICH_CHAPTER="all"
  fi
  if [ -z $PKGUSERFILE ]; then
    PKGUSERFILE="pkguser.tar.xz"
  fi
  if [ -z $TESTS ]; then #null
    TESTS="no"
  fi
  if [ -z $MAKE_KERNEL ]; then #null
    MAKE_KERNEL="no"
  fi
  if [ -z $AS_ROOT ]; then #null
    AS_ROOT="no"
  fi
  if [ -z $SYSTEMD ]; then #null
    SYSTEMD="no"
  fi
#
# store the values in the new config file
  echo "TZ=$TZ" | tee $cfg 
  echo "PAPER_SIZE=$PAPER_SIZE" | tee -a $cfg
  echo "LFS_BOOK_LOC_DIR=$HOME/LFS_SVN/$REPO" | tee -a $cfg
  echo "SVN_URL=svn://svn.linuxfromscratch.org/$REPO/" | tee -a $cfg
  echo "BOOK_VERSION=$BOOK_VERSION" | tee -a $cfg
  echo "SOURCES=$SOURCES" | tee -a $cfg
  echo "CLEAN_SRC_DIR=$CLEAN_SRC_DIR" | tee -a $cfg
  echo "BOOK=$BOOK" | tee -a $cfg
  echo "WHICH_CHAPTER=$WHICH_CHAPTER" | tee -a $cfg
  echo "PKGUSERFILE=$PKGUSERFILE" | tee -a $cfg
  echo "TESTS=$TESTS" | tee -a $cfg
  echo "MAKE_KERNEL=$MAKE_KERNEL" | tee -a $cfg
  echo "AS_ROOT=$AS_ROOT" | tee -a $cfg
  echo "SYSTEMD=$SYSTEMD" | tee -a $cfg
fi
#
# functions
#
configEdit () {
tempfile1=dialog_1
tempfile2=dialog_2
tempfile3=dialog_3
DIALOG=dialog # could set to gui dialog - xdialog, if availale
#test -n "$DISPLAY" && DIALOG=xdialog
# delete temp files on exit
trap "rm -f $tempfile1 $tempfile2 $tempfile3" 0 1 2 5 15
#
_edit () {
   items=$(awk -F\= '{print $1,$2}' $cfg)
   $DIALOG --title "" \
          --menu "LFS config file editor:" 0 0 0 $items 2> $tempfile1
#
   retval=$?
   parameter=$(cat $tempfile1)
#
   [ $retval -eq 0 ] && tochange=$parameter || return 1
   if [ "$tochange" = TZ ]; then
     display="Enter your local time zone. (If not known, run tzselect)"
   elif [ "$tochange" = PAPER_SIZE ]; then
     display="Probably letter or A4"
   elif [ "$tochange" = LFS_BOOK_LOC_DIR ]; then
     display="Enter the local directory to store the LFS Book"
   elif [ "$tochange" = SVN_URL ]; then
     display="Enter the svn url of the LFS book"
   elif [ "$tochange" = BOOK_VERSION ]; then
     display="LFS book version you want. Type BOOK to get the svn version, systemd to get the systemd version (type blank to get a list)."
   elif [ "$tochange" = BOOK ]; then
     display="Enter either svn or local (if local the book must be in $LFS_BOOK_LOC_DIR)"
   elif [ "$tochange" = WHICH_CHAPTER ]; then
     display="Enter chapter05, chapter06 or chapter08. Enter all to build them all. Enter update to update the core lfs packages."
   elif [ "$tochange" = SOURCES ]; then
     display="Either download or local (if local, source files must be in ${SOURCEDIR}/<book_version>)"
   elif [ "$tochange" = CLEAN_SRC_DIR ]; then
     display="If yes, all files in $WgetList in ${SOURCEDIR}/<book_version> will be deleted. Default is no"
   elif [ "$tochange" = PKGUSERFILE ]; then
     display="tar file containing the package user build files. Default is pkguser.tar.xz. Place the file in $LFS/sources"
   elif [ "$tochange" = TESTS ]; then
     display="Chapter 6 tests? Type eithe yes or no"
   elif [ "$tochange" = MAKE_KERNEL ]; then
     display="If no, kernel will stop at makeproper. If you want to use a .config, type yes,
place the .config file in \$LFS/sources and the kernel will be compiled and installed."
   elif [ "$tochange" = AS_ROOT ]; then
     display="If yes, install packages as root. If no, install as package user"
   elif [ "$tochange" = SYSTEMD ]; then
     display="If yes, systemd will control start-up, running and shutdown of the system. If no, will use sysvinit."
   fi
   val=$(awk -F\= -v x=$tochange '$1==x {print $2}' $cfg)
   $DIALOG --clear --title "Change value" \
          --inputbox "$display" 0 0 $val 2> $tempfile2
#
   $DIALOG --title "Confirmation"  --yesno "Commit ?" 0 0
   case $? in
       0) newval=$(cat $tempfile2)
          if [ "$newval" = "" ]; then
            $DIALOG --infobox "Blank value not allowed" 0 0
            sleep 1
          else
            awk -v x=$tochange -v n=$newval '
               BEGIN {FS=OFS="="}$1==x {$2=n} {print}
               ' $cfg > $cfg.tmp
            mv $cfg.tmp $cfg
          fi
       ;;
       1|255) $DIALOG --infobox "Value not changed" 0 0
              sleep 1
   ;;
   esac
   $DIALOG --textbox $cfg 0 0
}
#
_main () {
   $DIALOG --title "LFS config file editor" \
           --menu "Please choose an option:" 15 55 5 \
                   1 "View the config file" \
                   2 "Edit config file" \
                   3 "Exit from this menu" 2> $tempfile3
#
   retv=$?
   choice=$(cat $tempfile3)
   if [ $retv -eq 1 -o $retv -eq 255 ]; then
     echo "cancel pressed - exiting now"
     exit 1
   fi
#
   case $choice in
       1) $DIALOG --textbox $cfg 0 0
          _main
           ;;
       2) _edit
          _main 
           ;;
       3) return 
           ;;
   esac
}
_main
rm -rf $tempfile1 $tempfile2 $tempfile3 # just to be sure they are deleted
} #end configEdit
#
ChkLocalBook () {
localbookdir=$1
version=$2
ChkLocalBookExists $localbookdir
    return_val=$?
    if [ "$return_val" -eq $RETURN_PARAM ]; then # requested book not present
      echo "Requested book not present locally. Will svn it"
    else # book present, test if need to svn an update
      ChkLocalBookDetails $localbookdir $version
      return_val=$?
      if [ "$return_val" -eq $RETURN_PARAM ]; then
        exit 1
      fi
    fi
} # end ChkLocalBook
#
ChkLocalBookExists () {
local bookdir=$1
#
unset BookPath
for BookPath in $( find $bookdir -name index.xml -exec dirname {} ';' )
do
  if [ -e $BookPath/.svn ]; then # a book exists, check the version
    if [ "$BOOK_VERSION" = "Current_Development" ]; then
      version="BOOK"
    else
      version=$BOOK_VERSION
      case $version in
        */) # okay continue
            :
        ;;
        BOOK) # okay continue
            :
        ;;
        SYSTEMD|systemd) # okay continue
            version="systemd/"
        ;;
        [0-9]*) # not okay, didn't end with /
         version=${version}/
        ;;
      esac
    fi
    if [ "$version" != BOOK ]; then BookPath="$BookPath/";fi # add a /
    if [ "$BookPath" == "${bookdir}/${version}" ]; then
      return 0 #requested version is present locally
    fi
  fi
done
return $RETURN_PARAM #requested book not present locally
} #end ChkLocalBookExists
#
ChkLocalBookDetails () {
local bookdir=$1
local book_version=$2
#
if [[ "$book_version" = BOOK || "$book_version" = "systemd/" ]]; then
  # check the last svn date
  returned_array=( $(LastAccessSvn "$argument") )
  retval=$?
  if [ $retval -eq 0 ]; then # compare last svn date with today's date
    if [ ${returned_array[0]} -eq ${returned_array[1]} ]; then
      echo "The same book has already been downloaded today"
      echo "To use it, set BOOK=local in the config file."
      echo "To download it again, delete ${bookdir}/${book_version}"
      return $RETURN_PARAM
    else
      return 0
    fi
  else
    echo "Could not retrieve date of last svn - no entries file found."
    echo "Will svn it"
    return 0
  fi
else # book is a release version so don't update it
  echo "Requested book is present locally so will use it."
  echo "It is a release version so no update necessary."
  return $RETURN_PARAM
fi
} # end ChkLocalBookDetails
#
CleanLocalREPO () { # delete any files in the local directory
local bookdir=$1
local book_version=$2
if [ -d ${bookdir}/${book_version} ]; then #local dir exists
  if [ "$(ls -A ${bookdir}/${book_version})" ]; then
    rm -rf ${bookdir}/${book_version} # delete contents of local book dir
  fi
else  # create it
  install -v -m0755 -d ${bookdir}/${book_version}
fi
} # end CleanLocalREPO
#
GetSvnUrl () {
if [ "$SVN_URL" = blank ]; then
  SVN_URL="svn://svn.linuxfromscratch.org/LFS/"
fi
} # end GetSvnUrl
#
WhichLFSBook () {
Ignore="bootscripts"
PS3="Please select the book version : "
select TAG in 'Current Development' 'systemd' $( svn ls ${SVN_URL}tags | grep -vE "$Ignore" )
do
  case $TAG in
    '') echo >&2 "Please select a numbered option";;
    Current*)
      type=trunk
      version=BOOK
      BOOK_VERSION="Current_Development"
    ;;
    systemd)
      type=branches
      version="systemd"
      BOOK_VERSION="systemd"
    ;;
    ?*)
      type=tags
      version=$TAG
      BOOK_VERSION=$TAG
    ;;
  esac
  BOOK_SVN_URL="${SVN_URL}$type/$version"
  echo >&2 "You have selected '$TAG'"
  echo >&2 "$BOOK_SVN_URL"
  PS3="Is this correct? : "
  select confirm in Yes No
  do
    case $confirm in
      '') echo >&2 "Please enter 1 for Yes or 2 for No";;
      ?*) break
    esac
  done
  case $confirm in
    No) PS3="Please select the book version : ";;
# update the config file with the book version
   Yes) awk -v x=BOOK_VERSION -v n=$BOOK_VERSION '
             BEGIN {FS=OFS="="}$1==x {$2=n} {print}
             ' $cfg > $cfg.tmp
             mv $cfg.tmp $cfg
      break
  esac
done
} #end WhichLFSBook
#
SetLFSBook () {
case $BOOK_VERSION in
   Current_Development|BOOK)
         type=trunk
         version=BOOK
   ;;
   SYSTEMD|systemd)
         type=branches
         version=systemd
   ;;
   *)
         type=tags
         version=$BOOK_VERSION
   ;;
esac
} #end SetLFSBook
#
LastAccessSvn () {
local passed_array   # Local variable
local bookdir=$LFS_BOOK_LOC_DIR
BookLoc=${bookdir}/${version}
if [ -e ${BookLoc}/.svn/entries ]; then #check time of last svn
  EntriesDate=$( stat --printf=%y ${BookLoc}/.svn/entries | awk 'gsub(/-/,"") {printf $1}' )
  date=$(date +'%Y-%m-%d %H:%M:%S') # today's date
  read Y M D h m s <<< ${date//[-: ]/ }
  today=$Y$M$D
  passed_array=( $EntriesDate $today ) # return the last svn date and today
  echo "${passed_array[@]}"
  return 0
else
  return $RETURN_PARAM # no entries file found
fi
} # end LastAccessSvn
#
CheckoutSVN () {
local bookdir=$1
local book_version=$2
#
Url="${SVN_URL}${type}/${book_version}"
Tag=$book_version
#
echo "Will svn the LFS book at $Url"
echo "and place it in ${bookdir}/${Tag}"
svn co $Url ${bookdir}/${Tag} # get the requested book
#
} # end CheckoutSVN
#
LocalBook () {
if [ "$BOOK_VERSION" = Current_Development -o "$BOOK_VERSION" = BOOK ]; then
  type="trunk"
  version="BOOK"
elif [ "$BOOK_VERSION" = systemd ]; then
  type="branches"
  version="systemd"
else
  type="tags"
  version=$BOOK_VERSION
fi
} # end LocalBook
#
DumpCommands () {
# $1 is the Repository - LFS in this case
local bookdir=$2
local book_version=$3
if [ "$book_version" = systemd ]; then book_version="systemd/"; fi
#
REPODIR=${bookdir}/${book_version}
target=$( echo $1 | awk '{print tolower($1)}')
SVNINFO="$(svn info $REPODIR | awk '{printf $0"|"}')"
# Note, tagged | on the end so it can be used as a record separator later
# e.g.
# echo $SVNINFO | awk 'BEGIN{ RS = "|" }; {print $0}'
# will 'reconstitute it
SVNrevision=$( echo $SVNINFO | awk 'BEGIN{ RS = "|" };/Revision/ {print $0}' )
for dir in $DumpedCommands; do
  if [ ! -d $dir ]; then
    install -vd $dir
    install -vd $Dumpedhtml
    touch ${dir}/.revision
  fi
done
for dir in $DumpedCommands; do
  if [ -e "$dir" -a "$SVNrevision" != "$( cat $dir/.revision | awk '/Revision/ {print $0}')" ]; then
    rm -rf $dir
    rm -rf $Dumpedhtml
    install -d $dir
    install -d $Dumpedhtml
    pushd $REPODIR
            make -j1 DUMPDIR=$DumpedCommands BASEDIR=$Dumpedhtml $target dump-commands
            for dir in $DumpedCommands $Dumpedhtml; do
              echo $SVNINFO | awk 'BEGIN{ RS = "|" }; {print $0}' > ${dir}/.revision
            done
    popd
    break
  fi
done
} # end of DumpCommands
#
CleanSourceDir () {
local srcdir=$1
local wgetlistFile=$2
if [ -d $srcdir ]; then
# delete any file in $srcdir that is in $wgetlistFile
  if [ -e $wgetlistFile ]; then
    while read FUrl; do
      if [[ ${FUrl:0:1} != '#' ]]; then # ignore file if it has a hash at the start
        fileinlist=$( echo $FUrl | awk -F\/ '{print $NF}' )
        [ -e ${srcdir}/${fileinlist} ] && rm -rf ${srcdir}/${fileinlist}
      fi
    done < $wgetlistFile
  fi
else
  rm -rf $srcdir # remove any file called $srcdir - it needs to be a dir
  install -v -m0755 -d $srcdir
fi
} #end CleanSourceDir
#
GetSource () {
local bookvers=$1
local srcdir=$2
local wgetlistFile=$3
local bookdir=$4
#
if [[ "$bookvers" = BOOK || "$bookvers" = "systemd" ]]; then # get sources from the urls in $wgetlist
  if [ ! -d $srcdir ]; then install -v -d $srcdir; fi
    REPODIR=${bookdir}/${bookvers}
    make -j1 -f ${REPODIR}/Makefile -C $REPODIR BASEDIR=$srcdir ${srcdir}/${wgetlist} ${srcdir}/md5sums
    md5sums=${srcdir}/md5sums

    pushd $srcdir
      RequiredFiles=$( md5sum --quiet -c $md5sums 2> /dev/null | awk -F\: '!/OK/{printf "%s ",$1}' )
    popd
    for File in $RequiredFiles; do
      Url=$( grep $File $wgetlistFile )
      case $File in
         lfs-bootscripts*)
             if [ ! -e ${srcdir}/${File} ]; then
              wget $wgetopts -c $Url -O ${srcdir}/${File}
             fi
         ;;
         ?*)
             wget $wgetopts -c $Url -O ${srcdir}/${File}
         ;;
      esac
    done
else # use anduin to get the source tarball for the released book version
  bookvers=${bookvers%/}
  File="lfs-packages-${bookvers}.tar"
  sourceURL="http://anduin.linuxfromscratch.org/sources/LFS/lfs-packages/${File}"
  wget $wgetopts -c $sourceURL -O ${SOURCEDIR}/${File}
  tar xvf ${SOURCEDIR}/${File} -C $SOURCEDIR
  rm -v ${SOURCEDIR}/${File} # untared so remove it
fi
#set all the sources to owner lfs
chown -R -h lfs:root $srcdir # because chapter05.sh is run as lfs
chmod 755 $srcdir
chmod 644 ${srcdir}/*
#
} #end GetSource
#
GetSystemdSources () {
local srcdir=$1
local wgetlistFile=$2
while read FileUrl; do
  fileNam=$( echo $FileUrl | awk -F\/ '{print $NF}' )
  wget $wgetopts -c $FileUrl -O ${srcdir}/${fileNam}
done < $wgetlistFile
chown -R -h lfs:root $srcdir
chmod 644 ${srcdir}/*
#
} # end GetSystemdSources
# 
ChkSrcPresent () { 
# $1 is the directory to check and $2 is the $wgetlist of files
fileMissing=false
local dirtochk=$1
local wgetlistFile=$2
while read FileUrl; do
  if [[ ${FileUrl:0:1} != '#' ]]; then # ignore file if it has a hash at the start
    filetofind=$( echo $FileUrl | awk -F\/ '{print $NF}' )
    if [ ! -e ${dirtochk}/${filetofind} ]; then 
      echo "'$filetofind' not present in source dir"
      fileMissing=true
    fi   
  fi
done < $wgetlistFile
if $fileMissing; then 
  return $RETURN_PARAM
else
  return 0
fi
} # end ChkSrcPresent
#
ChkEmptySrcFiles () {
local srcdir=$1
zeroLenFiles=$(ls -l $srcdir | awk '!/^d/&&$5==0 {print $NF}')
len=${#zeroLenFiles}
if [ $len -eq 0 ]; then
  return 0
else
  echo -e "These files are empty:\n$zeroLenFiles"
  return $RETURN_PARAM
fi
} # end ChkEmptySrcFiles
#
GetPkgVersion () {
# $1 is the location of the src package
# $2 is the name of the package
# $3 is the name to trim against - usually tar
local pkgloc=$1
local pkgnm=$2
local trim=$3
local fnd
local fileExt
local pkgvers=""
fnd=$( ls -l $pkgloc | grep ${pkgnm}[0-9].*.tar.*z* | awk '{print $NF}' )
fileExt="${fnd#*${pkgnm}}"
pkgvers="${fileExt%.${trim}*}"
rtrvers=($pkgvers)
} # end GetPkgVersion
#
GetLinuxVersion () {
local srcdir=$1
commandloc=$2
# first find the version of the downloaded kernel source
linuxfnd=$( ls -l $srcdir | grep ' linux-[0-9]' | awk '{print $NF}' )
if [ -z $linuxfnd ]; then # linux src not found in wget-list file - return
  return $RETURN_PARAM
else
  linuxExt="${linuxfnd#*-}"
  linuxvers="${linuxExt%.tar*}"
# now find the version of the kernel in the lfs commands
  while read cmdLine; do
    if [[ ${cmdLine:0:1} != '#' ]]; then # ignore line if it has a hash at the start
      linuxcomfnd=$( echo $cmdLine | awk -F\/ '{print $NF}' | grep vmlinuz-[0-9] )
      if [ ! -z $linuxcomfnd ]; then break; fi
    fi
  done < ${commandloc}/*-kernel
  linuxcomExt="${linuxcomfnd#*-}"
  linuxcomvers="${linuxcomExt%-lfs*}"
  return 0
fi
} # end GetLinuxVersion
#
combineScripts () {
declare -a commands=("${!1}")
declare -a buildWrap=("${!2}")
local combine=""
local numc=${#commands[@]}
local numb=${#buildWrap[@]}
countc=0 # counter for the combine array
countbl=0 # counter for build lines written
inc=false # switch for whether a configure, make and install section is present
cont=0 # number of continuation lines
ifDoc=false # true if an if block containing a doc
#
for (( i=0; i<$numb; i++ )); do
  case "${buildWrap[i]}" in
    configure_commands*)
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: line
      for (( jk=$countg; jk<$numc; jk++ )); do
        case ${commands[jk]} in
           make*) # assume either a make command or make install
              countg=$jk
              break
           ;;
           *install*) # test to see if part of a continuation squence
              case ${commands[jk]} in
                 *\\) # a continuation line
                    if [ $cont -gt 0 ]; then # part of configure sequence so store it
                      storit[cont++]="${commands[jk]}"
                    else # assume an install cont line
                      countg=$jk
                      break
                    fi
                 ;;
                 './configure'*) # might be a configure with install in it
                    combine[countc++]="  ${commands[jk]}"
                    inc=true
                 ;;
                 *)
                    countg=$jk
                    break
                 ;;
              esac
           ;;
           *)
              case "${commands[jk]}" in
                 *\\)
                    storit[cont++]="${commands[jk]}"
                 ;;
                 *)
                    # write with any continuation lines
                    if [ $cont -gt 0 ]; then
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                      combine[countc++]="  ${commands[jk]}"
                      cont=0
                      inc=true
                    else
                      combine[countc++]="  ${commands[jk]}" # configure command
                      inc=true # found at least one configure command
                    fi
                    if [ $[jk+1] -eq $numc ]; then countg=$jk; fi
                 ;;
              esac
           ;;
        esac
      done
      if [ $cont -gt 0 ]; then
        for (( l=0; l<$cont; l++ )); do
          combine[countc++]="  ${storit[l]}"
        done
        combine[countc++]="  ${commands[countg++]}"
        inc=true
        cont=0
      fi
      if ! $inc; then
        combine[countc++]='  echo "no configure script for this package"'
      fi
    ;;
    make_commands*)
      inc=false
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: command
      for (( jl=$countg; jl<$numc; jl++ )); do
        case ${commands[jl]} in
           *install*) # assume an install command
              countg=$jl
              break
           ;;
           'cp -v src/{msgfmt'*) # gettext ch5
              countg=$jl
              break
           ;;
           'cp -v src/{fstab-decode'*) # sysvinit (systemd) ch6
              countg=$jl
              break
           ;;
           'cp -v perl cpan'*) # perl ch5
              countg=$jl
              break
           ;; 
           *)
              case "${commands[jl]}" in
                 *\\)
                     storit[cont++]="${commands[jl]}"
                 ;;
                 *)
                     if [ $cont -gt 0 ]; then # write the continuation lines
                       for (( l=0; l<$cont; l++ )); do
                         combine[countc++]="  ${storit[l]}"
                       done
                       combine[countc++]="  ${commands[jl]}"
                       cont=0
                       inc=true
                     else
                       combine[countc++]="  ${commands[jl]}" # make commands
                       inc=true #at least one make command found
                     fi
                     if [ $[jl+1] -eq $numc ]; then # no more commands
                       countg=$jl
                       if [[ "${commands[$countg]}" != *make* ]]; then
                         ((countc--))
                       fi
                     fi
                 ;;
              esac
           ;;
        esac
      done
       if ! $inc; then
         combine[countc++]='  echo "no make script for this package"'
       fi
    ;;
    install_commands*)
      inc=false
      foundDoc=false
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: command
      for (( jm=$countg; jm<$numc; jm++ )); do
        case ${commands[jm]} in
          *install*)
             case "${commands[jm]}" in
               *\\) # cont line so store it
                  case "${commands[jm]}" in
                    *'/usr/share/doc'*) # cont line contains a doc
                        foundDoc=true
                        storit[cont++]="${commands[jm]}"
                    ;;
                    *) # no doc in this cont line
                        storit[cont++]="${commands[jm]}"
                    ;;
                  esac
               ;;
               'make'*'=/usr/share/doc'*|*'DOCDIR=/usr/share/doc'*) # genuine install command
                    if [ $cont -gt 0 ]; then # first write out cont lines
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                    fi
                    combine[countc++]="  ${commands[jm]}"
                    inc=true
               ;;
               *'/usr/share/doc'*) # don't write a doc install
                    :
               ;;
               *) # install line so write it out
                    if [ $cont -gt 0 ]; then # first write out cont lines
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                    fi 
                    combine[countc++]="  ${commands[jm]}"
                    inc=true
                    cont=0
                    countg=$[jm+1]
               ;;
             esac
          ;;
          '#'*) # comment line so ignore it
              if [ $[jm+1] -eq $numc ]; then countg=$[jm+1]; fi
          ;;
          if*) # starts with if so if a doc, will need to delete the closing fi
                   case ${commands[jm]} in
                   *'/usr/share/doc'*)
                       ifDoc=true
                       case ${commands[j]} in
                          *\\) # a continuation line so store it
                                storit[cont++]="${commands[jm]}"
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       storit[cont++]="${commands[jm]}"
                   ;;
                   *) # if block but not a doc or a cont line
                       echo ${commands[jm]}
                   ;;
                esac
          ;;
          *'/usr/share/doc'*) # would have got here because we have a cont line
              cont=0 # doc so don't write it out
              countg=$[jm+1] # update countg in case this is the last line
          ;;
          "for "*) # begining of a for loop so break
             countg=$jm
             cont=0
             inc=true
             break
          ;;
          'cp -v src/{fstab-decode'*|'cp -v src/last'*|'cp -v man/{last'*|'cp -v man/{fstab-decode'*) # sysvinit (systemd) ch6
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$[jm+1]
          ;;
          'cp -v perl cpan/podlators'*|'mkdir -pv /tools/lib/perl5'*|'cp -Rv lib/* /tools/lib/perl5'*) # perl ch5
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$[jm+1]
          ;;
          'make -C ld clean'*|'make -C ld LIB_PATH=/usr/lib:/lib'*|'cp -v ld/ld-new /tools/bin'*) # binutils pass 2
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$[jm+1]
          ;;
          'cp -v src/{msgfmt'*) # gettext ch5
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$[jm+1]
          ;;
          'cp -rv dest/include/* /usr/include'*) # linux-headers copy
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$[jm+1]
          ;;
          *)
             case "${commands[jm]}" in
               *\\) # if a cont line, then store it
                     storit[cont++]="${commands[jm]}"
               ;;
               'cp -v src/msgfmt'*)
                     combine[countc++]="  ${commands[jm]}"
                     countg=$[jm+1]
                     cont=0
                     inc=true
               ;;
               *)
                     if ! $foundDoc; then # write out any cont lines
                       if [ $cont -gt 0 ]; then
                         for (( l=0; l<$cont; l++ )); do
                           combine[countc++]="  ${storit[l]}"
                         done
                         combine[countc++]="  ${commands[jm]}"
                         cont=0
                         inc=true
                       else
                         countg=$jm
                         cont=0
                         inc=true
                         break
                       fi
                     else # continuation of a doc line so ignore it
                       cont=0
                     fi
               ;;
             esac
          ;;
        esac
      done
      if ! $inc; then
        combine[countc++]='  echo "no install script for this package"'
      fi
    ;;
    *)
      if [ $i -lt $countbl ]; then
        :
      else
        combine[countc++]=${buildWrap[i]}
        ((countbl++)) # increment because have written another build command
      fi
    ;;
  esac
done
rtr=(${combine[@]})
} # end combineScript
#
getBuild () {
local abuild=""
buildfile=${LFS}/tools/${pkgFileName}/build
if [ ! -e $buildfile ]; then
  return $RETURN_PARAM
else
IFS='
'
abuild=( $( < $buildfile ) )
rtrnBuild=(${abuild[@]})
return 0
fi
} # end getBuild
#
getComms () {
# $1 is the chapter containing the commands
# $2 is the package name
local acom=""
local bcom=""
local localpkgname=$2
chapreq=$1
if [ -e ${DumpedCommands}/${chapreq}/*-${CmdName} ]; then
  curfile=${DumpedCommands}/${chapreq}/*-${CmdName}
else
  return $RETURN_PARAM
fi
IFS='
'
acom=( $( < $curfile ) )
#
# can adjust the commands here if necessary
#
case $localpkgname in
     *)
             rtrnCom=(${acom[@]})
             return 0
     ;;
esac
} # end getComms
#
GetCommands () {
#get access to the arrays
rtrnBuild=""
getBuild
return_val=$?
if [ "$return_val" -eq $RETURN_PARAM ]; then # no build file present
  return $RETURN_PARAM
else
buildScripts=(${rtrnBuild[@]})
rtrnCom=""
getComms $Chapter $PkgName
ret_val=$?
if [ "$ret_val" -eq $RETURN_PARAM ]; then # no commands found
  echo "No commands found for package $PkgName in $lfscommands"
  echo "Check you have the correct book written to $lfscommands"
  echo "Exiting now."
  exit 1
fi
commandScripts=(${rtrnCom[@]})
numclines=${#commandScripts[@]} # # of commands
#
# place commands in output until first configure found
countg=0
contline=0
for line in "${commandScripts[@]}"; do
  case "$line" in
       cp*) # expect has a cp with configure in it
         echo "$line"
         ((countg++))
       ;;
       sed*)
         echo "$line"
         ((countg++))
       ;;
       *configure*|*Configure*) #Perl has Configure!
         countg=$countg-$contline
         break
       ;;
       "perl Makefile"*) # xml-parser is a perl module
         countg=$countg-$contline
         break
       ;;
       make*) #begins with make
         break
       ;;
       *)
# if a continuation line, store in cache
         case "$line" in
            *\\)
             cacheit[contline++]="$line"
             ((countg++))
            ;;
            *)
             if [ $contline -gt 0 ]; then # continuation line found
               for (( l=0; l<$contline; l++ )); do
                 echo "${cacheit[l]}"
               done
               echo "$line"
               contline=0
               ((countg++)) # count # of commands written to output
               if [ $countg -eq $numclines ]; then
                 return 0
               fi
             else
               echo "$line"
               ((countg++)) # count # of commands written to output
               if [ $countg -eq $numclines ]; then 
                 return 0 
               fi
             fi
            ;;
          esac
       ;;
  esac
done
#
rtr=""
combineScripts commandScripts[@] buildScripts[@]
scriptOut=(${rtr[@]})
for t in "${scriptOut[@]}"
do
  echo $t
done
if [ $countg -lt $((numclines)) ]; then # output remaining commands
  contin=false # switch for a continuation line
  contline=0   # # of continuation lines found
  iftest=false # test for an if block with a /usr/share/doc in it
  for (( k=$countg; k<$((numclines)); k++ )); do
    case ${commandScripts[k]} in
       install*)
              case ${commandScripts[k]} in
                 *'/usr/share/doc'*)
                     case ${commandScripts[k]} in
                        *\\) # a continuation line
                           contin=true
                        ;;
                     esac
                 ;;
                 *\\) # a continuation line
                     cacheit[contline++]=${commandScripts[k]}
                     contin=true
                 ;;
                 *) # install but not a doc or a cont line
                     echo ${commandScripts[k]}
                 ;;
              esac
       ;;
       if*) # starts with if so if a doc, will need to delete the closing fi
              case ${commandScripts[k]} in
                 *'/usr/share/doc'*)
                     iftest=true
                     case ${commandScripts[k]} in
                        *\\) # a continuation line
                           contin=true
                        ;;
                     esac
                 ;;
                 *\\) # a continuation line
                     cacheit[contline++]=${commandScripts[k]}
                     contin=true
                 ;;
                 *) # if test but not a doc or a cont line
                     echo ${commandScripts[k]}
                 ;;
              esac
       ;;
       ln*) # a symlink so write it - e.g. vim73
              echo ${commandScripts[k]}
       ;;
       *'/usr/share/doc'*)
              case ${commandScripts[k]} in
                  *\\) # a continuation line
                     contin=true
                  ;;
                  *)
                     if $contin; then # is a doc, so don't write
                       contin=false
                       contline=0
                     fi
                  ;;
              esac
       ;;
       "fi"*)
              if $iftest; then # end of a doc if test - don't write it
                iftest=false
              else
                echo ${commandScripts[k]} # if block is not a doc
              fi
       ;;
       *)
              if ! $iftest; then # commands not within a doc if block
                case ${commandScripts[k]} in
                    *\\) # continuation line, store it
                         cacheit[contline++]=${commandScripts[k]}
                         contin=true
                    ;;
                    *)
                         if [ $contline -gt 0 ]; then # write out continuation lines
                           for (( l=0; l<$contline; l++ )); do
                             echo "${cacheit[l]}"
                           done
                           contin=false
                           contline=0
                         fi
                         echo ${commandScripts[k]}
                    ;;
                esac
              fi
       ;;
    esac
  done
fi
return 0
fi
} # end GetCommands
#
dbusComms () {
local dbuscom=""
dbuscom[0]="./configure --prefix=/usr \\"
dbuscom[1]="            --sysconfdir=/etc \\"
dbuscom[2]="            --localstatedir=/var \\"
dbuscom[3]="            --libexecdir=/usr/lib/dbus-1.0 \\"
dbuscom[4]="            --docdir=/usr/share/doc/dbus-1.8.0 \\"
dbuscom[5]="            --with-system-pid-file=/run/dbus/pid \\"
dbuscom[6]="            --with-system-socket=/run/dbus/system_bus_socket \\"
dbuscom[7]="            --disable-static \\"
dbuscom[8]="            --enable-systemd \\"
dbuscom[9]="            --with-console-auth-dir=/run/console/ \\"
dbuscom[10]="            --with-systemdsystemunitdir=/usr/lib/systemd/system"
dbuscom[11]="make"
dbuscom[12]="make install"
dbuscom[13]="ln -s /etc/machine-id /var/lib/dbus"
rtrncommands=(${dbuscom[@]})
} # end dbusComms
#
systemdComms () {
local systemdcom=""
systemdcom[0]='cat > config.cache << "EOF"'
systemdcom[1]="KILL=/usr/bin/kill"
systemdcom[2]="HAVE_BLKID=1"
systemdcom[3]='BLKID_LIBS="-lblkid"'
systemdcom[4]='BLKID_CFLAGS="-I/tools/include/blkid"'
systemdcom[5]="HAVE_LIBMOUNT=1"
systemdcom[6]='MOUNT_LIBS="-lmount"'
systemdcom[7]='MOUNT_CFLAGS="-I/tools/include/libmount"'
systemdcom[8]="cc_cv_CFLAGS__flto=no"
systemdcom[9]="EOF"
systemdcom[10]='sed -i "s:blkid/::" $(grep -rl "blkid/blkid.h")'
systemdcom[11]="patch -Np1 -i ../systemd-${systemdvers}-compat-1.patch"
systemdcom[12]="sed -e '/install-touch-usr-hook/d' \\"
systemdcom[13]="    -e '/touch -c \\\$(DESTDIR)\\/\\\$(prefix)/d' -i Makefile.in"
systemdcom[14]="./configure --prefix=/usr                        \\"
systemdcom[15]="            --sysconfdir=/etc                    \\"
systemdcom[16]="            --localstatedir=/var                 \\"
systemdcom[17]="            --libexecdir=/usr/lib                \\"
systemdcom[18]="            --config-cache                       \\"
systemdcom[19]="            --docdir=/usr/share/doc/systemd-${systemdvers}  \\"
systemdcom[20]="            --with-rootprefix=                   \\"
systemdcom[21]="            --with-rootlibdir=/usr/lib           \\"
systemdcom[22]="            --with-firmware-path='/usr/lib/firmware/updates:/usr/lib/firmware' \\"
systemdcom[23]="            --disable-gudev                      \\"
systemdcom[24]="            --without-python                     \\"
systemdcom[25]="            --with-dbuspolicydir=/etc/dbus-1/system.d               \\"
systemdcom[26]="            --with-dbusinterfacedir=/usr/share/dbus-1/interfaces    \\"
systemdcom[27]="            --with-dbussessionservicedir=/usr/share/dbus-1/services \\"
systemdcom[28]="            --with-dbussystemservicedir=/usr/share/dbus-1/system-services"
systemdcom[29]="make LIBRARY_PATH=/tools/lib"
systemdcom[30]="make LIBRARY_PATH=/tools/lib install"
systemdcom[31]="for tool in runlevel reboot shutdown poweroff halt telinit; do"
systemdcom[32]="     ln -sfv ../bin/systemctl /usr/bin/\$tool"
systemdcom[33]="done"
systemdcom[34]="ln -sfv ../lib/systemd/systemd /usr/sbin/init"
systemdcom[35]='sed -i "s@0775 root lock@0755 root root@g" /usr/lib/tmpfiles.d/legacy.conf'
systemdcom[36]="systemd-machine-id-setup"
systemdcom[37]="rm -rfv /usr/lib/rpm"
rtrncommands=(${systemdcom[@]})
} # end systemdComms
#
sysvinitComms () {
local sysvinitcom=""
sysvinitcom[0]="make -C src fstab-decode"
sysvinitcom[1]="make -C src killall5"
sysvinitcom[3]="cp -v src/{fstab-decode,killall5} /usr/sbin"
sysvinitcom[6]="cp -v man/{fstab-decode,killall5,pidof}.8 /usr/share/man/man8"
sysvinitcom[7]="ln -sv ../sbin/killall5 /usr/bin/pidof"
rtrncommands=(${sysvinitcom[@]})
} # end sysvinitComms
#
GetInternalCommands () {
# $1 is the function name that creates the commands
# get access to the build array
rtrnBuild=""
getBuild
return_val=$?
if [ $return_val -eq $RETURN_PARAM ]; then # no build file present
  return $RETURN_PARAM
else
  buildScripts=(${rtrnBuild[@]})
  declare -a rtrncommands=""
  eval $1
  commandScripts=(${rtrncommands[@]})
  numclines=${#commandScripts[@]}
  countg=0 # initialize commands counter
  cont=0
  for line in "${commandScripts[@]}"; do
    case "$line" in
       sed*)
# test if sed has continuation line
         case "$line" in
           *\\)
             cacheit[cont++]="$line"
             ((countg++))
           ;;
           *)
             echo "$line"
             ((countg++))
           ;;
         esac
       ;;
       *configure*)
         break
       ;;
       make*) #  if no configure script present
         break
       ;;
       "perl Makefile.PL") # for perl modules
         break
       ;;
       *)
         case "$line" in
            *\\) # if a continuation line then store in cache
             cacheit[cont++]="$line"
             ((countg++))
            ;;
            *)
             if [ $cont -gt 0 ]; then # continuation line found
               for (( l=0; l<$cont; l++ )); do
                 echo "${cacheit[l]}"
               done
               echo "$line"
               cont=0
               ((countg++)) # count # of commands written to output
             else
               echo "$line"
               ((countg++)) # count # of commands written to output
             fi
            ;;
          esac
       ;;
    esac
  done
#
  rtr=""
  combineScripts commandScripts[@] buildScripts[@]
  scriptOut=(${rtr[@]})
  for t in "${scriptOut[@]}"; do
    echo $t
  done
  if [ $countg -lt $numclines ]; then # output remaining commands
    contin=false
    for (( k=$countg; k<$numclines; k++ )); do
      if [[ "${commandScripts[k]}" == install* ]]; then #don't install docs
        case ${commandScripts[k]} in
            *\\) # continuation line
                contin=true
            ;;
            */usr/share/doc*) # doc so don't write
                continue
            ;;
            *) # not a doc so write it
                echo ${commandScripts[k]}
            ;;
        esac
      else
        if $contin; then
          if [[ "${commandScripts[k]}" == *\\ ]]; then # more continuation
            :
          else
            contin=false
          fi
        else
          echo ${commandScripts[k]}
        fi
      fi
    done
  fi
  return 0
fi
} # end GetInternalCommands
#
Header () {
echo writing the script to: $Output
case "$Chapter" in
     chapter05)
       cat > $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -eq 0 ]; then 
  echo "Please do NOT run this script as root."
  echo "Run it as user lfs."
  exit 1
fi
if [ $(whoami) != "lfs" ]; then echo Please run this script as user lfs. ; exit 1; fi
#
EOF
echo "builddir05=$builddir05" >> $Output
       ;;
     chapter06|chapter08)
       if [ "$Chapters" != update ]; then
         cat > $Output << "EOF"
#!/tools/bin/bash -e
#
if [ $UID -ne 0 ]; then echo Please run this script as root. ; exit 1; fi
#
EOF
       else
         cat > $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -ne 0 ]; then echo Please run this script as root. ; exit 1; fi
#
EOF
       fi
echo "PkgUserDir=$PkgUserDir" >> $Output
       ;;
esac
echo "me=\$0
LFS=$LFS
SVNINFO=\"$SVNINFO\"
sourcedir=$sourcedir
sourceloc=$sourceloc
BuildLog=$BuildLog" >> $Output
case "$Chapter" in
     chapter05)
       CreateBuildDir >> $Output
       unpack05 >> $Output
     ;;
     chapter06|chapter08)
       if $as_root; then CreateBuildDirasroot >> $Output; fi
     ;;
esac
} # end Header
#
cleanPkgDir () {
    cat >> $Output << "EOF"
cleanpkgdir () {
# $1 is the dir to clean
# $2 is the pkg name
local dirtoClean=$1
local pkgtoClean=$2
rm -rf ${dirtoClean}/*.err
rm -rf ${dirtoClean}/*.log
rm -rf ${dirtoClean}/.${pkgtoClean}
rm -rf ${dirtoClean}/*.gz
rm -rf ${dirtoClean}/*.xz
rm -rf ${dirtoClean}/*.bz2
rm -rf ${dirtoClean}/*.tgz
rm -rf ${dirtoClean}/*.zip
rm -rf ${dirtoClean}/*.patch
}
EOF
} # end cleanPkgDir
#
unpackpkguser () {
#
# $1 is the pkguser filename
local pkguserFile=$1
pkgFileName="${pkguserFile%.tar*}"
if [ ! -e ${LFS}${sourcedir}/${pkguserFile} ]; then
  if [ -d ${LFS}/tools/${pkgFileName} ]; then
    return 0
  else
    return $RETURN_PARAM
  fi
else
  if [ -d ${LFS}/tools/${pkgFileName} ]; then # remove the dir first
    rm -rf ${LFS}/tools/${pkgFileName}
  fi
  if [ -d ${LFS}/tools ]; then
    tar -xvf ${LFS}${sourcedir}/${pkguserFile} -C ${LFS}/tools --no-same-owner
    rm ${LFS}${sourcedir}/${pkguserFile}
    return 0
  else
    echo "Directory ${LFS}/tools does not exist."
    echo "Please create it. Exiting now."
    exit 1
  fi
fi
} #end unpackpkguser
#
copypkguserbin () { # when installing as root, may need listpkg
cat >> $Output << "EOF"
copypkguserbin_ () {
FuncName=copypkguserbin
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
EOF
echo "pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/bin/* /usr/bin/
}
EOF
} # end copypkguserbin
#
pkguser () {
cat >> $Output << "EOF"
pkguser_ () {
FuncName=pkguser
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
EOF
echo "pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/sbin/* /tools/bin
cp ${pkguserdir}/usr/sbin/* /tools/bin
if [ $(uname -m) = x86_64 ]; then
  mv /tools/bin/su64 /tools/bin/su
else
  mv /tools/bin/su32 /tools/bin/su
fi
if [ ! -d /etc/pkgusr/skel-package ]; then
  install -v -m0755 -d /etc/pkgusr/skel-package
fi
cp -r ${pkguserdir}/etc/* /etc/pkgusr/
if [ ! -d /usr/lib/pkgusr ]; then
  install -v -m0755 -d /usr/lib/pkgusr
fi
cp ${pkguserdir}/lib/* /usr/lib/pkgusr/
cp ${pkguserdir}/bin/* /usr/bin/
cp ${pkguserdir}/usr/sbin/* /usr/sbin/
if [ "$(grep -q ^install\: /etc/group;echo $?)" != 0 ]; then
  groupadd -g 9999 install
fi
# make sure pkgusers can write to the logfile
chgrp install $BuildLog
chmod 664 $BuildLog
# set some initial dirs to install and sticky
chown 0:9999 $(cat ${pkguserdir}/installdirs.lst)
chmod 1775 $(cat ${pkguserdir}/installdirs.lst)
EOF
# if using sysvinit for init then build uses /usr/libexec
if [ "$SYSTEMD" = no ]; then
  echo "chgrp install /usr/libexec
chmod 1775 /usr/libexec" >> $Output
fi
cat >> $Output << "EOF"
#
cat >> /etc/pkgusr/bash_profile << "BashProfile"
#
complete -o default -o nospace -A user su finger pinky
export PkgName=$LOGNAME
if [ -e /usr/src/core/${LOGNAME}/build -a ! -e ~/.${LOGNAME} ]; then
  cd
  bash -e /usr/src/core/${LOGNAME}/build
  exit
fi

BashProfile
install -v -d /usr/src/core/${LOGNAME}
echo "${FuncName}" >> $BuildLog
}
EOF
} # end of pkguser
#
update_pkguser () {
cat >> $Output << "EOF"
update_pkguser_ () {
FuncName=update_pkguser
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
EOF
echo "pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/sbin/* /tools/bin
cp ${pkguserdir}/usr/sbin/* /tools/bin
if [ $(uname -m) = x86_64 ]; then
  mv /tools/bin/su64 /tools/bin/su
else
  mv /tools/bin/su32 /tools/bin/su
fi
# make sure pkgusers can write to the logfile
chgrp install $BuildLog
chmod 664 $BuildLog
#
cat > /etc/pkgusr/bash_profile << "BashProfile"
export PATH=/usr/lib/pkgusr:/bin:/usr/bin:/opt/jdk/bin:/opt/ant/bin:/opt/qt/bin
export PROMPT_COMMAND='PS1="package \u:"$(pwd)"> "'
cd
EOF
echo "PkgUserDir=$PkgUserDir" >> $Output
cat >> $Output << "EOF"
complete -o default -o nospace -A user su finger pinky
export PkgName=$LOGNAME
EOF
echo "if [ -e \${PkgUserDir}/\${LOGNAME}/$build -a ! -e ~/.\${LOGNAME} ]; then
  cd
  bash \${PkgUserDir}/\${LOGNAME}/$build" >> $Output
cat >> $Output << "EOF"
  exit
fi
BashProfile
echo "${FuncName}" >> $BuildLog
}
EOF
} # end update_pkguser
#
delSrcFile () {
echo "cd \$curdir
cd ..
rm -rf \$curdir"
} # end of delSrcFile
#
Function () {
case $PkgName in
    kernfs|chroot)
        if [ "$Chapters" != update ]; then
          WriteScript
          return
        fi
    ;;
esac
echo "${FuncName}_ () {" >> $Output
case $Chapters in
    all|chapter05|chapter06|chapter08)
        case "$Chapter" in
            chapter05)
                echo "FuncName=$FuncName" >> $Output 
                TestBuiltCh5
                case $FuncName in
                   adjusting|stripping)
                      echo "starttime=\$( date +%s )" >> $Output
                   ;;
                   *)
                      echo "PkgName=$PkgName
SrcName=$SrcName
starttime=\$( date +%s )" >> $Output
                      cat >> $Output << "EOF"
CreateBuildDir $FuncName
EOF
                      case $FuncName in
                           gccpass1|gccpass2)
                               cat >> $Output << "EOF"
# chapter 5 gcc requires unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.*z* .
done
EOF
                           ;;
                      esac
                      echo "unpack05" >> $Output
                   ;;
                esac
            ;;
            chapter06|chapter08)
                case $PkgName in
                   chroot|kernfs|strippingagain|readjusting|adjusting|creatingdirs|createfiles)
                      echo "FuncName=$FuncName" >> $Output
                      cat >> $Output << "EOF"
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
EOF
                   ;;
                   *)
                      echo "PkgName=$PkgName" >> $Output
                      cat >> $Output << "EOF"
if [ -e "$PkgUserDir/$PkgName/.$PkgName" ]; then
  echo "skipping $PkgName"
  return
fi
EOF
                      if ! $as_root; then
                        cat >> $Output << "EOF"
install -v -m0755 -d ${PkgUserDir}/${PkgName}
touch ${PkgUserDir}/${PkgName}/build
echo "BuildLog=$BuildLog" > ${PkgUserDir}/${PkgName}/build
cat >> ${PkgUserDir}/${PkgName}/build << "IPS"
set +h
PkgName=$LOGNAME
CUR_DIR=$HOME
EOF
                        echo "SrcName=$SrcName
sourceloc=$sourceloc" >> $Output
                        if [ "$Chapter" = chapter08 ];then echo "sourcedir=$sourcedir" >> $Output; fi
                      else # building as root
                        echo "CreateBuildDirasroot \$PkgName
SrcName=$SrcName
echo \"Building \$PkgName\"" >> $Output
                      fi
                   ;;
                esac
                case $PkgName in
                   chroot|revisedchroot|kernfs|strippingagain|readjusting|adjusting|creatingdirs|createfiles)
                      :
                   ;;
                   kernel)
                      unpack >> $Output
                      ret_val=$?
                      if [ $ret_val -eq $RETURN_PARAM ]; then # no .config file found
                        echo "***********************************************"
                        echo "You set MAKE_KERNEL to yes but the .config file"
                        echo "is not in ${LFS}${sourcedir}. Place it there in"
                        echo "order to compile the kernel source."
                        echo "***********************************************"
                      fi
                      cat >> $Output << "EOF"
unpack
EOF
                   ;;
                   *)
                      unpack >> $Output
                      cat >> $Output << "EOF"
unpack
curdir=$( echo $PWD ) #store the current dir for later deletion
EOF
                   ;;
                esac
            ;;
        esac
    ;;
    update)
        case $PkgName in
            adjusting)
                echo "FuncName=$FuncName" >> $Output
                cat >> $Output << "EOF"
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
EOF
            ;;
            *)
                echo "PkgName=$PkgName" >> $Output
                cat >> $Output << "EOF"
if [[ "$(grep -q ^$PkgName $BuildLog;echo $?)" == 0 && -e "${PkgUserDir}/${PkgName}/.${PkgName}" ]]; then
  echo "skipping $PkgName" #package already built so skip
  return
else
  echo "Building $PkgName"
fi
rm -rf ${PkgUserDir}/${PkgName}/build
touch ${PkgUserDir}/${PkgName}/build
echo "BuildLog=$BuildLog" > ${PkgUserDir}/${PkgName}/build
cleanpkgdir ${PkgUserDir}/${PkgName} $PkgName
cat >> ${PkgUserDir}/${PkgName}/build << "IPS"
set +h
PkgName=$LOGNAME
CUR_DIR=$HOME
EOF
                echo "SrcName=$SrcName
sourceloc=$sourceloc" >> $Output
                if [ "$PkgName" = kernel ]; then
                  echo "sourcedir=$sourcedir" >> $Output
                fi
                unpack >> $Output
                cat >> $Output << "EOF"
unpack
curdir=$( echo $PWD ) #store the current dir for later deletion
EOF
            ;;
        esac # PkgName
    ;;
esac
WriteScript
closefunction
} # end of Function
closefunction () {
case "$Chapter" in
    chapter05)
      case $FuncName in
        stripping)
        cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$FuncName $unpacktime $elapsedtime" >> $BuildLog
EOF
       ;;
       *)
       cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$FuncName $unpacktime $elapsedtime" >> $BuildLog
EOF
       ;;
      esac
       case $PkgName in
           stripping)
            cat >> $Output << "EOF"
echo "removing contents of the build directory"
rm -rf ${LFS}${builddir05}/*
echo "Delete the build dir as root"
echo 
echo "You should now store a copy of the /tools dir somewhere on your host"
echo "in case there is a build problem in chapter06"
}
EOF
           ;;
           *)
           cat >> $Output << "EOF"
}
EOF
           ;;
       esac
    ;; #close function for the chapter05.sh script
    chapter06)
       case $PkgName in
           chroot|kernfs|readjusting|strippingagain|creatingdirs|createfiles)
             if [ "$Chapters" != update ]; then
               cat >> $Output << "EOF"
echo "${FuncName}" >> $BuildLog
}
EOF
             fi
           ;;
           adjusting) # need this for chapter06 and update
               cat >> $Output << "EOF"
echo "${FuncName}" >> $BuildLog
}
EOF
           ;;
           *)
             if ! $as_root; then
               cat >> $Output << "EOF"
touch ~/.${PkgName}
endtime=$( date +%s )
set +e
EOF
             else
                cat >> $Output << "EOF"
touch ${PkgUserDir}/${PkgName}/.${PkgName}
endtime=$( date +%s )
set +e
EOF
             fi
delSrcFile >> $Output
if [ "$PkgName" = glibc ]; then #also delete glibc-build
  echo "rm -rf glibc-build" >> $Output
elif [ "$PkgName" = binutils ]; then #also delete binutils-build
  echo "rm -rf binutils-build" >> $Output
elif [ "$PkgName" = gcc ]; then #also delete gcc-build
  echo "rm -rf gcc-build" >> $Output
fi
           cat >> $Output << "EOF"
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
         if ! $as_root; then
           echo "IPS" >> $Output
           setuplinks # setup any preprocessing commands
           if [[ ! -z $doFirst || ! -z $links ]]; then resolvelinks; fi
           if [ "$Chapters" != update ]; then
             cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName
fi
EOF
           fi
           if [[ ! -z $doFirst || ! -z $links ]]; then # preprocessing
cat >> $Output << "EOF"
resolvelinks
EOF
           fi
           cat >> $Output << "EOF"
su $PkgName
if [ ! -e $PkgUserDir/$PkgName/.$PkgName ]; then
  echo "${PkgName} failed"
  exit 1
fi
EOF
echo "chown \$PkgName:\$PkgName \${PkgUserDir}/\${PkgName}/$build" >> $Output
           if [ "$Chapters" != update ]; then
             case $PkgName in
                linux-headers|man-pages) # don't ldconfig - nor installed until glibc
                    :
                ;;
                *)
                     echo "ldconfig" >> $Output
                ;;
             esac
           else
             echo "ldconfig" >> $Output
           fi
#set required dirs to be install dirs plus some other stuff
           case $PkgName in
             linux-headers) #/usr/include/scsi
               if [ "$Chapters" != update ]; then
                 cat >> $Output << "EOF"
chgrp install /usr/include/scsi
chmod g+w,o+t /usr/include/scsi
EOF
               fi
             ;;
             glibc) #/usr/share/info/dir
               cat >> $Output << "EOF"
chown root:install /usr/share/info/dir
chmod 664 /usr/share/info/dir
chgrp install /usr/include/sys # for libcap
chmod g+w,o+t /usr/include/sys
EOF
if [ "$SYSTEMD" = yes ]; then
  cat >> $Output << "EOF"
chgrp install /usr/lib/systemd
chmod g+w,o+t /usr/lib/systemd
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/lib/tmpfiles.d
chmod g+w,o+t /usr/lib/tmpfiles.d
EOF
fi
             ;;
             kmod)
               cat >> $Output << "EOF"
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
EOF
             ;;
             pkg-config) #/usr/share/aclocal
               cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
chgrp install /usr/lib/pkgconfig
chmod g+w,o+t /usr/lib/pkgconfig
EOF
             ;;
             ncurses)
               cat >> $Output << "EOF"
chown 0.0 /etc/ld.so.cache
EOF
             ;;
             inetutils) # ping, etc setuid root
               cat >> $Output << "EOF"
chown root /usr/bin/ping*
chmod 4755 /usr/bin/ping*
chown root /usr/bin/traceroute
chmod 4755 /usr/bin/traceroute
chown root /usr/bin/{rcp,rlogin,rsh}
chmod 4755 /usr/bin/{rcp,rlogin,rsh}
EOF
             ;;
             util-linux) # mount setuid root
               cat >> $Output << "EOF"
chown root /usr/bin/{mount,umount}
chmod 4755 /usr/bin/{mount,umount}
chown root:tty /usr/bin/wall
chmod 2755 /usr/bin/wall
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
EOF
if [ "$SYSTEMD" = yes ]; then
                 cat >> $Output << "EOF"
chgrp install /usr/lib/systemd # if dbus installed
chmod g+w,o+t /usr/lib/systemd
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
EOF
fi
if [ "$Chapters" = update ]; then
  cat >> $Output << "EOF"
chown root /usr/bin/su
chmod 4755 /usr/bin/su
EOF
fi
             ;;
             shadow)
               cat >> $Output << "EOF"
pwconv
grpconv
chown root /usr/bin/su
chmod 4755 /usr/bin/su
EOF
if [ "$SYSTEMD" = yes ]; then
  echo "chown root /usr/bin/passwd
chmod 4755 /usr/bin/passwd" >> $Output
else
  echo "chown root /bin/passwd
chmod 4755 /bin/passwd" >> $Output
fi
             ;;
             bash) #/usr/share/aclocal
               cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
chown -h bash:bash /usr/bin/sh
EOF
             ;;
             man-db) #/es,it,ru
               cat >> $Output << "EOF"
chgrp install /usr/share/man/es
chgrp install /usr/share/man/es/man*
chgrp install /usr/share/man/it
chgrp install /usr/share/man/it/man*
chmod g+w,o+t /usr/share/man/es
chmod g+w,o+t /usr/share/man/es/man*
chmod g+w,o+t /usr/share/man/it
chmod g+w,o+t /usr/share/man/it/man*
EOF
             ;;
             man-pages)
               if [ "$Chapters" != update ]; then
                 cat >> $Output << "EOF"
chown man-pages /usr/share/man/man*
EOF
               fi
             ;;
             perl)
               echo "case \$(uname -m) in
   x86_64) archi=x86_64-linux
   ;;
   *)      archi=i686-linux
   ;;
esac
chgrp install /usr/lib/perl5/${perlvers}/\$archi
chmod g+w,o+t /usr/lib/perl5/${perlvers}/\$archi
chgrp install /usr/lib/perl5/site_perl/${perlvers}
chmod g+w,o+t /usr/lib/perl5/site_perl/${perlvers}
chgrp install /usr/lib/perl5/site_perl/${perlvers}/\$archi
chmod g+w,o+t /usr/lib/perl5/site_perl/${perlvers}/\$archi" >> $Output
             ;;
             xml-parser)
               echo "case \$(uname -m) in
   x86_64) archi=x86_64-linux
   ;;
   *)      archi=i686-linux
   ;;
esac
chgrp install /usr/lib/perl5/site_perl/${perlvers}/\$archi/XML
chmod g+w,o+t /usr/lib/perl5/site_perl/${perlvers}/\$archi/XML
chgrp install /usr/lib/perl5/site_perl/${perlvers}/\$archi/auto
chmod g+w,o+t /usr/lib/perl5/site_perl/${perlvers}/\$archi/auto
chgrp install /usr/lib/perl5/site_perl/${perlvers}/\$archi/auto/XML
chmod g+w,o+t /usr/lib/perl5/site_perl/${perlvers}/\$archi/auto/XML
chgrp install /usr/lib/perl5/${perlvers}/\$archi/perllocal.pod
chmod 664 /usr/lib/perl5/${perlvers}/\$archi/perllocal.pod" >> $Output
             ;;
             grub)
               cat >> $Output << "EOF"
chgrp install /etc/bash_completion.d
chmod g+w,o+t /etc/bash_completion.d
EOF
             ;;
             eudev)
               cat >> $Output << "EOF"
chgrp install /lib/udev/rules.d
chmod g+w,o+t /lib/udev/rules.d
chgrp install /lib/firmware
chmod g+w,o+t /lib/firmware
chgrp install /usr/share/gtk-doc/html
chmod g+w,o+t /usr/share/gtk-doc/html
EOF
             ;;
             systemd)
               cat >> $Output << "EOF"
chgrp install /usr/lib/udev/rules.d
chmod g+w,o+t /usr/lib/udev/rules.d
chgrp install /etc/udev/rules.d
chmod g+w,o+t /etc/udev/rules.d
chgrp install /etc/dbus-1
chmod g+w,o+t /etc/dbus-1
chgrp install /usr/share/pkgconfig
chmod g+w,o+t /usr/share/pkgconfig
chgrp install /usr/share/polkit-1 # for polkit
chmod g+w,o+t /usr/share/polkit-1
chgrp install /usr/share/polkit-1/actions
chmod g+w,o+t /usr/share/polkit-1/actions
chgrp install /etc/xdg # for at-spi2-core
chmod g+w,o+t /etc/xdg
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
chgrp install /usr/lib/systemd/system/sockets.target.wants # for dbus
chmod g+w,o+t /usr/lib/systemd/system/sockets.target.wants
chgrp install /usr/lib/systemd/system/multi-user.target.wants
chmod g+w,o+t /usr/lib/systemd/system/multi-user.target.wants
# systemd-detect-virt-install-hook
/usr/sbin/setcap cap_dac_override,cap_sys_ptrace=ep /usr/bin/systemd-detect-virt
chown root:systemd-journal /var/log/journal
chmod 2755 /var/log/journal
EOF
             ;;
             dbus)
               cat >> $Output << "EOF"
chown root /usr/lib/dbus-1.0/dbus-daemon-launch-helper
chmod 4750 /usr/lib/dbus-1.0/dbus-daemon-launch-helper
chgrp install /usr/lib/dbus-1.0
chmod g+w,o+t /usr/lib/dbus-1.0
chgrp install /usr/share/dbus-1
chmod g+w,o+t /usr/share/dbus-1
chgrp install /usr/share/dbus-1/services
chmod g+w,o+t /usr/share/dbus-1/services
chgrp install /usr/share/dbus-1/system-services
chmod g+w,o+t /usr/share/dbus-1/system-services
chgrp install /usr/include/dbus-1.0/dbus
chmod g+w,o+t /usr/include/dbus-1.0/dbus
chgrp install /etc/dbus-1/system.d
chmod g+w,o+t /etc/dbus-1/system.d
chgrp install /usr/lib/systemd/
chmod g+w,o+t /usr/lib/systemd/
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/lib/systemd/system/sockets.target.wants
chmod g+w,o+t /usr/lib/systemd/system/sockets.target.wants
chgrp install /usr/lib/systemd/system/multi-user.target.wants
chmod g+w,o+t /usr/lib/systemd/system/multi-user.target.wants
EOF
             ;;
             vim) # man pages
               cat >> $Output << "EOF"
chgrp install /usr/share/man/fr*
chgrp install /usr/share/man/it*
chgrp install /usr/share/man/ja
chgrp install /usr/share/man/pl*
chgrp install /usr/share/man/ru*
chmod g+w,o+t /usr/share/man/fr*
chmod g+w,o+t /usr/share/man/it*
chmod g+w,o+t /usr/share/man/ja
chmod g+w,o+t /usr/share/man/pl*
chmod g+w,o+t /usr/share/man/ru*
EOF
             ;;
           esac # end case pkgname
           echo "} # end $FuncName" >> $Output
         else
echo "} # end $FuncName" >> $Output
         fi # end of as_root test
         ;; #name loop
       esac
    ;; # close chapter06 loop
   chapter08)
# add any required firmware files
      echo "# *** required firmware files ***
install -v -d -m755 /usr/lib/firmware/ar3k
install -D /tools/${pkgFileName}/firmware/ar3k/*.dfu /usr/lib/firmware/ar3k/
cp -r /tools/${pkgFileName}/firmware/ar3k ${PkgUserDir}/\${PkgName}/linux-*/firmware/
# rm ${PkgUserDir}/\${PkgName}/linux-*/firmware/ar3k/*.dfu # these are in /usr/lib/firmware/ar3k" >> $Output
      if ! $as_root; then
         cat >> $Output << "EOF"
touch ~/.${PkgName}
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
         echo "IPS" >> $Output
         setuplinks # setup any preprocessing commands
         if [[ ! -z $doFirst || ! -z $links ]]; then resolvelinks; fi
         cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName
fi
EOF
         if [[ ! -z $doFirst || ! -z $links ]]; then # preprocessing
cat >> $Output << "EOF"
resolvelinks
EOF
         fi
         cat >> $Output << "EOF"
su $PkgName
if [ ! -e $PkgUserDir/$PkgName/.$PkgName ]; then
  echo "${PkgName} failed"
  exit 1
fi
ldconfig
EOF
         if [ "$Chapters" != update ]; then
           if [ "$SYSTEMD" = yes ]; then
             cat >> $Output << "EOF"
rm ${PkgUserDir}/{coreutils/{.coreutils,build},dbus/build,systemd/build,shadow/{.shadow,build}} # in prep for blfs
EOF
           else
             cat >> $Output << "EOF"
rm ${PkgUserDir}/{coreutils/{.coreutils,build},eudev/build,shadow/{.shadow,build}} # in prep for blfs
EOF
           fi
         fi
      else
         cat >> $Output << "EOF"
touch ${PkgUserDir}/${PkgName}/.${PkgName}
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
         if [ "$SYSTEMD" = yes ]; then
           cat >> $Output << "EOF"
rm ${PkgUserDir}/{coreutils/.coreutils,shadow/.shadow} # in prep for blfs
EOF
         else
           cat >> $Output << "EOF"
rm ${PkgUserDir}/{coreutils/.coreutils,eudev/.eudev,shadow/.shadow} # in prep for blfs
EOF
         fi
      fi # end as_root test
#
      if [ "$MAKE_KERNEL" = yes ]; then
      # write out the cp commands
        kerneldir=${PkgUserDir}/kernel/linux*
        rtrnCom=""
        CmdName=kernel
        getComms $Chapter $PkgName
        for line in ${rtrnCom[@]}; do
          case $line in
             "cp -v"*) # cp the bzImage, System.map and the .config file
                    line=${line#"cp -v "}
                    linout=$(echo "cp -v ${kerneldir}/${line}")
                    if [ ! -z $linuxvers ]; then
                      echo $linout | sed -e 's/'"$linuxcomvers"'/'"$linuxvers"'/' \
                      >> $Output
                    else
                      echo $linout >> $Output
                    fi
              ;;
          esac
        done
        if [ "$Chapters" != update ]; then
          rtrnCom=""
          CmdName=theend
          getComms "chapter09" $PkgName
          for line in ${rtrnCom[@]}; do
            case $line in
              DISTRIB_CODENAME*)
                echo $line | sed -e 's@<your name here>@John@' \
                >> $Output
              ;;
              *)
                echo $line >> $Output
              ;;
            esac
          done
        fi
      fi # end MAKE_KERNEL
      echo "}" >> $Output
    ;;
esac
} #end closefunction
#
setuplinks () { # setup preprocessing
case $PkgName in
    gcc)
        doFirst=""
        links="/usr/lib/libstdc++.la /usr/lib/libgcc_s.so{,.1} /usr/lib/libstdc++.so{,.6}"
    ;;
    bash)
        doFirst=""
        links="/bin/bash"
    ;;
    coreutils)
        doFirst=""
        links="/bin/{cat,echo,false,pwd,stty} /etc/group"
    ;;
    inetutils)
        doFirst=""
        links="/usr/bin/{dnsdomainname,ping,ping6,traceroute,rcp,rlogin,rsh} /usr/share/man/man1/dnsdomainname.1"
    ;;
    kernel) # install /usr/lib/firmware dir
        if [ "$Chapters" != update ]; then
          doFirst="mkdir -pv /usr/lib/firmware && chgrp install /usr/lib/firmware && chmod 1775 /usr/lib/firmware"
        else
          doFirst=""
        fi
        links=""
    ;;
    ncurses)
        doFirst=""
        links="/etc/ld.so.cache"
    ;;
    perl)
        doFirst=""
        links="/usr/bin/perl"
    ;;
    shadow)
        doFirst=""
        links="/usr/share/man/man{5/passwd.5,3/getspnam.3} /etc/{passwd,shadow,group,gshadow}{,-}"
    ;;
    sysklogd)
        doFirst=""
        links="/usr/share/man/man8/sysklogd.8"
    ;;
    systemd)
        doFirst="if [ \"\$(grep -q ^systemd-journal\: /etc/group;echo \$?)\" != 0 ]; then
  groupadd -g 190 systemd-journal
fi"
        links=""
    ;;
    eudev)
        doFirst=""
        links="/lib/{firmware,udev,udev/devices,udev/devices/pts}"
    ;;
    util-linux)
        doFirst=""
        links=""
        if [ "$Chapters" = update ]; then
          links="/usr/bin/{mount,su,umount,wall} /usr/share/man/man1/su.1"
        fi
    ;;
    *)
        doFirst=""
        links=""
    ;;
esac
} # end setuplinks
#
resolvelinks () {
# At the beginning of chapter 6 there are symlinks that point to the tools dir
# Trouble is these are owned by root so need to change owner to the package user
echo "resolvelinks () {
$doFirst
for link in $links
do
  if [ -e "\$link" ]; then
    chown -h \$PkgName:\$PkgName \$link # change owner to package user so can overwrite
  fi
done
return
}" >> $Output
} #end resolvelinks
#
CreateBuildDir () {
# only used in chapter 5
cat << "EOF"
CreateBuildDir () {
BuildDir=${LFS}${builddir05}/${1}
if [ ! -e $BuildDir ]; then install -d $BuildDir; fi
cd $BuildDir
CUR_DIR=".."
}
EOF
} #end CreateBuildDir
#
CreateBuildDirasroot () {
cat << "EOF"
CreateBuildDirasroot () {
BuildDirasroot=${PkgUserDir}/${1}
if [ ! -e $BuildDirasroot ]; then install -d $BuildDirasroot; fi
cd $BuildDirasroot
CUR_DIR=".."
}
EOF
} # end CreateBuildDirasroot
#
unpack05 () { # need the LFS bit for chapter05 only
cat << "EOF"
unpack05 () {
starttime=$( date +%s )
cp ${LFS}${sourceloc}/${SrcName}*.* .
cd $(tar vxf ${SrcName}*z* | awk -F\/ 'END{print $1}')

endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
}
EOF
} #end unpack05
unpack () {
case $PkgName in
    glibc)
    cat << "EOF"
unpack () {
starttime=$( date +%s )
cp ${sourceloc}/${SrcName}*.* .
if [ -e ${sourceloc}/tzdata*.tar.*z* ]; then
  cp ${sourceloc}/tzdata*.tar.*z* .
else
  echo "*** Warning - No tzdata found in $sourceloc ***"
  echo "Should there be a file there?"
fi
cd $(tar vxf ${SrcName}*z* | awk -F\/ 'END{print $1}')
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
}
EOF
    ;;
    eudev)
    cat << "EOF"
unpack () {
starttime=$( date +%s )
cp ${sourceloc}/${SrcName}*.* .
cd $(tar vxf ${SrcName}[0-9].[0-9].tar.*z* | awk -F\/ 'END{print $1}')
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
}
EOF
    ;;
    kernel)
    cat << "EOF"
unpack () {
starttime=$( date +%s )
cp ${sourceloc}/${SrcName}*.* .
cd $(tar vxf ${SrcName}*z* | awk -F\/ 'END{print $1}')
make mrproper
EOF
if [ "$MAKE_KERNEL" = yes ]; then
  if [ ! -e ${LFS}${sourcedir}/.config ]; then return $RETURN_PARAM; fi
    cat << "EOF"
cp ${sourcedir}/.config .
EOF
fi
    cat << "EOF"
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
}
EOF
   ;;
    *)
    cat << "EOF"
unpack () {
starttime=$( date +%s )
cp ${sourceloc}/${SrcName}*.* .
cd $(tar vxf ${SrcName}*z* | awk -F\/ 'END{print $1}')
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
}
EOF
   ;;
esac
return 0
} # end unpack
#
TestBuiltCh5 () {
    cat >> $Output << "EOF"
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName"
  return
elif [ "$FuncName" = stripping ]; then
  echo "stripping"
else
  echo "Building $FuncName"
fi
EOF
} #end TestBuiltCh5
#
WriteScript () {
case $PkgName in
    acl) # present in systemd version of lfs
        GetCommands \
        | sed -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_BIN_DIR)/d' getfacl\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_BIN_DIR)/d' setfacl\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_BIN_DIR)/d' chacl\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man1\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man3\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man5\/Makefile" \
              -e "/make install/i\  sed -i '0,/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_INC_DIR)/{//d;}' include\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_INC_DIR)\\\/sys/d' include\/Makefile" \
              -e '/mv -v/,/ln -sfv/d' \
        >> $Output
    ;;
    attr) 
        GetCommands \
        | sed -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_BIN_DIR)/d' attr\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_BIN_DIR)/d' getfattr\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_BIN_DIR)/d' setfattr\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man1\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man2\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man3\/Makefile" \
              -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man5\/Makefile" \
              -e '/mv -v/,/ln -sfv/d' \
        >> $Output
    ;;
    automake)
        GetCommands \
        | sed -e '/sed -i/,/make -j4 check/d' \
        >> $Output
    ;;
    bash)
        GetCommands \
        | sed -e '/nobody/d' \
              -e '/--login/d' \
        >> $Output
    ;;
    bc)
       GetCommands \
        | sed -e '/echo "quit"/d' \
        >> $Output
    ;;
    binutils)
          # check if the build dir exists
        GetCommands \
         | sed -e '/expect -c/d' \
         | awk '{
if ($1 == "mkdir" && $2 =="-v")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
  print $0;
}' \
         >> $Output
    ;;
    bzip2) # ch6 only
        if [ "$Chapters" != update ]; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e "/patch/i sed -e 's\/^CFLAGS=\\\(.\*\\\)\$\/CFLAGS=\\\1 \\\\\$(BIGFILES)\/' -i ./Makefile-libbz2_so" \
                   -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
                   -e 's/cp -v bzip2-shared \/bin\/bzip2/cp -v bzip2-shared \/usr\/bin\/bzip2/' \
                   -e 's/cp -av libbz2.so\* \/lib/cp -av libbz2.so\* \/usr\/lib/' \
                   -e '/ln -sv ..\/..\/lib/d' \
                   -e '/rm -v/i ln -sv libbz2.so.1.0 /usr/lib/libbz2.so' \
                   -e 's/bunzip2,bzcat,bzip2/bunzip2,bzcat/' \
                   -e 's/\/bin\/bunzip2/\/usr\/bin\/bunzip2/' \
                   -e 's/\/bin\/bzcat/\/usr\/bin\/bzcat/' \
             >> $Output
          else
            GetCommands \
             | sed -e "/patch/i sed -e 's\/^CFLAGS=\\\(.\*\\\)\$\/CFLAGS=\\\1 \\\\\$(BIGFILES)\/' -i ./Makefile-libbz2_so" \
                   -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
             >> $Output
          fi
        else
          GetCommands \
           | sed -e "/patch/i sed -e 's\/^CFLAGS=\\\(.\*\\\)\$\/CFLAGS=\\\1 \\\\\$(BIGFILES)\/' -i ./Makefile-libbz2_so" \
                 -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
                 -e 's/cp -v bzip2-shared \/bin\/bzip2/cp -v bzip2-shared \/usr\/bin\/bzip2/' \
                 -e 's/cp -av libbz2.so\* \/lib/cp -av libbz2.so\* \/usr\/lib/' \
                 -e '/ln -sv ..\/..\/lib/d' \
                 -e 's/bunzip2,bzcat,bzip2/bunzip2,bzcat/' \
                 -e 's/\/bin\/bunzip2/\/usr\/bin\/bunzip2/' \
                 -e 's/\/bin\/bzcat/\/usr\/bin\/bzcat/' \
           >> $Output
        fi
    ;;
    changingowner) # is in chapter05 but can't change owner as not root
        continue
    ;;
    coreutils)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/uptime/uptime \\\n\              --libexecdir=\/usr\/lib/' \
                 -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                 -e '/mv -v \/usr\/bin\/{cat/,/mv -v \/usr\/bin\/chroot/d' \
                 -e '/mv -v \/usr\/bin\/{head/d' \
           >> $Output
        else
          GetCommands \
           | sed -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
           >> $Output
        fi
    ;;
    createfiles)
        # can't start a new shell just yet - it'll stop the script
        GetCommands \
         | sed '/exec \/tools\/bin\/bash --login +h/d' \
         >> $Output
    ;;
    creatingdirs)
        if [ "$SYSTEMD" = yes ]; then # symlink /bin, /lib and /sbin to /usr...
          GetCommands \
           | sed -e 's/bin,boot,etc\/{opt,sysconfig},home,lib/boot,etc\/{opt,sysconfig},home/' \
                 -e 's/sbin,srv,var/srv,var/' \
                 -e '/var\/tmp/a mkdir -pv /usr/{bin,include,lib,src}' \
                 -e 's/{,local\/}{bin/local\/{bin/' \
                 -e 's/mkdir -v/mkdir -pv/' \
                 -e '/ln -sv share/i if [[ ! -L \/usr\/man && ! -L \/usr\/doc && ! -L \/usr\/info ]]; then' \
                 -e 's/{man,doc,info} \$dir/{man,doc,info} \$dir\nfi/' \
                 -e 's/x86_64) ln -sv lib \/lib64/x86_64) ln -sv usr\/lib \/lib64/' \
                 -e '/ln -sv \/run \/var/i mkdir -pv \/run\/lock' \
                 -e '/mkdir -pv \/var\/{opt/a for dir in bin lib; do\n\  ln -sv usr\/${dir} \/${dir}\n\done\n\ln -sv usr\/bin \/sbin\n\ln -sv bin /usr/sbin' \
           >> $Output
        else
          GetCommands \
           | sed -e '/ln -sv \/run \/var/i mkdir -pv \/run\/lock' \
           >> $Output
        fi
    ;;
    dbus)
          GetInternalCommands dbusComms \
           | sed -e 's/\/usr\/share\/doc\/dbus-1.8.0/\/usr\/share\/doc\/dbus-'"${dbusvers}"'/' \
           >> $Output
    ;;
    e2fsprogs)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                 -e 's/cd build/cd e2fsprogs-build/' \
                 -e 's/bindir=\/bin    /bindir=\/usr\/bin/' \
                 -e '/with-root-prefix/i\               --libdir=\/usr\/lib       \\\n\               --sbindir=\/usr\/bin      \\' \
                 -e '/cp -v \/tools/,/rm -v \/lib\/libblkid.so.1/d' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                 -e 's/cd build/cd e2fsprogs-build/' \
           >> $Output
         fi
    ;;
    findutils)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/locate/locate --libexecdir=\/usr\/lib\/findutils/' \
                 -e '/mv -v/,/sed -i/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    flex)
        if [ "$Chapters" = update ]; then # don't re-create /usr/bin/lex
          GetCommands \
           | sed -e '/ln -s flex/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    gawk)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/prefix=\/usr/prefix=\/usr --libexecdir=\/usr\/lib/' \
           >> $Output
        else
          GetCommands >> $Output
        fi 
    ;;
    gcc)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/..\/..\/libexec\///' \
                 -e 's/with-system-zlib/with-system-zlib          \\\n\       --libexecdir=\/usr\/lib/' \
                 -e "/ln -sv gcc/ a set +e" \
           | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
print $0;
}' \
           >> $Output
        else
          GetCommands \
           | sed -e "/ln -sv gcc/ a set +e" \
           | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
print $0;
}' \
           >> $Output
        fi
        echo "set -e" >> $Output
    ;;
    glibc)
        if [ "$Chapters" != update ]; then
          # set up glibc's timezone
          # + fix the builddir issue
          GetCommands \
           | sed -e 's/obsolete-rpc/obsolete-rpc  \\\n\      --libexecdir=\/usr\/lib/' \
                 -e '/tzselect/d' \
                 -e 's/zic/\/usr\/sbin\/zic/' \
                 -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
           | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
print $0
}' \
           | awk '{if ($1 == "mkdir" && $NF =="/etc/ld.so.conf.d")
print "if [ ! -e "$NF" ]; then\n  "$1" -v "$NF"\nfi\n";
else
print $0
}' \
           >> $Output
        else # update so don't need most of the commands
          GetCommands \
           | sed -e 's/obsolete-rpc/obsolete-rpc  \\\n\    --libexecdir=\/usr\/lib/' \
                 -e '/touch \/etc\/ld.so.conf/d' \
                 -e '/mkdir -pv \/usr\/lib\/locale/,/mkdir -pv \/etc\/ld.so.conf.d/d' \
           | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
print $0
}' \
           >> $Output
        fi
    ;;
    gmp)
        # if building for 64bit need to remove config for 32
        GetCommands \
         | sed -e '/ABI=32/d' \
         >> $Output
    ;;
    grep)
        if [ "$SYSTEMD" = yes ]; then
           GetCommands \
            | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
            >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    groff)
        if [ "$Chapters" = update ]; then
          GetCommands \
           | sed -e 's/\*\*EDITME<paper_size>EDITME\*\*/'$PAPER_SIZE'/' \
                 -e 's/prefix=\/usr/prefix=\/usr \\\n              --sysconfdir=\/etc \\\n              --with-appresdir=\/etc\/X11\/app-defaults/' \
                 -e '/End of editable block/d' \
                 -e '/ln -sv/d' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/\*\*EDITME<paper_size>EDITME\*\*/'$PAPER_SIZE'/' \
                 -e '/End of editable block/d' \
           >> $Output
        fi
    ;;
    grub)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/--sbindir=\/sbin/--sbindir=\/usr\/bin/' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    gzip)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                 -e '/mv -v/d' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    inetutils)
        if [ "$SYSTEMD" = yes ]; then
          if [ "$Chapters" != update ]; then
            GetCommands \
             | sed -e '/disable-logger/i\      --libexecdir=/usr/lib  \\' \
                   -e '/mv -v/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/disable-logger/i\      --libexecdir=/usr/lib  \\' \
                   -e 's/disable-servers/disable-servers \\\n              --disable-hostname \\\n              --disable-ifconfig/' \
                   -e '/mv -v/d' \
             >> $Output
          fi
        else
          GetCommands  >> $Output
        fi
    ;;
    kernel)
        if [ "$MAKE_KERNEL" = yes ]; then
          if [ "$Chapters" != update ]; then
            GetCommands \
             | sed -e '/make mrproper/,/End of editable block/d' \
                   -e '/cp -v arch/,/cp -v .config/d' \
                   -e 's/linux-'"${linuxcomvers}"'/linux-'"${linuxvers}"'/' \
             >> $Output
          else # don't need usb.conf
            GetCommands \
             | sed -e '/make mrproper/,/End of editable block/d' \
                   -e '/cp -v arch/,/End \/etc\/modprobe.d\/usb.conf/d' \
                   -e '/EOF/d' \
                   -e 's/linux-'"${linuxcomvers}"'/linux-'"${linuxvers}"'/' \
             >> $Output
          fi
        fi
    ;;
    kernfs) # add changingowner as the first command
        GetCommands \
         | sed -e '/mkdir -pv \$LFS\/{dev,proc,sys/i chown -R root:root $LFS/tools' \
         >> $Output
    ;;
    kmod)
        if [ "$SYSTEMD" = yes ]; then
          if [ "$Chapters" != update ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                   -e 's/rootlibdir=\/lib/rootlibdir=\/usr\/lib/' \
                   -e 's/ln -sv ..\/bin\/kmod \/sbin/ln -sv ..\/bin\/kmod \/usr\/sbin/' \
                   -e 's#/bin/lsmod#/usr/bin/lsmod#' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                   -e 's/rootlibdir=\/lib/rootlibdir=\/usr\/lib/' \
                   -e '/for target in depmod/,/ln -sv kmod/d' \
             >> $Output
          fi
        else
          GetCommands >> $Output
        fi
    ;;
    libcap)
        GetCommands \
         | sed -e '/mv -v/,/ln -sfv/d' \
         >> $Output
    ;;
    libstdc++)
        GetCommands \
         | awk '{
if ($1 == "mkdir" && $2 =="-pv")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
  print $0;
}' \
         >> $Output
    ;;
    man-db)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/bin\/grap/bin\/grap --libexecdir=\/usr\/lib/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    ncurses)
        if [ "$SYSTEMD" = yes ]; then
           GetCommands \
            | sed -e '/mv -v \/usr\/lib\/libncursesw.so.5\* \/lib/d' \
                  -e '/ln -sfv ..\/..\/lib\/\$(readlink/d' \
            >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    procps)
        if [ "$SYSTEMD" = yes ]; then # add the sysctl.conf file
          if [ "$Chapters" != update ]; then
            GetCommands \
             | sed -e '/sed -i/,/make check/d' \
                   -e '/ln -sfv/a touch \/etc\/sysctl.conf' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/sed -i/,/make check/d' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          fi
        else
           GetCommands >> $Output
        fi
    ;;
    psmisc)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e '/mv -v/d' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    readline)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/--libdir=\/lib/--libdir=\/usr\/lib/' \
                 -e '/mv -v/,/rm -v/d' \
                 -e '/ln -sfv/d' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    sed)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    shadow)
        # assume no cracklib support
        # don't install foreign man pages
        # don't set root passwd
        # setup shadow pssswd files
        # delete pwconv and grpconv because cannot lock /etc/passwd
        # do pwconv and grpconv later as root
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e '/DICTPATH/d' \
                 -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\       -e 's\/zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
                 -e '/mv -v/d' \
                 -e '/passwd root/d' \
                 -e '/pwconv/ i touch /etc/shadow\nchmod 640 /etc/shadow' \
                 -e '/grpconv/ i touch /etc/gshadow\nchmod 640 /etc/gshadow' \
                 -e '/pwconv/d' \
                 -e '/grpconv/d' \
           >> $Output
        else
          GetCommands \
           | sed -e '/DICTPATH/d' \
                 -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\       -e 's\/zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
                 -e '/passwd root/d' \
                 -e '/pwconv/ i touch /etc/shadow\nchmod 640 /etc/shadow' \
                 -e '/grpconv/ i touch /etc/gshadow\nchmod 640 /etc/gshadow' \
                 -e '/pwconv/d' \
                 -e '/grpconv/d' \
           >> $Output
        fi
    ;;
    stripping)
        # strip always exits with 1, so toggle bash's -e flag
        echo "set +e" >> $Output
        GetCommands \
        >> $Output
        echo "set -e" >> $Output
    ;;
    strippingagain)
        if [ "$Chapters" != update ]; then
          GetCommands \
           | sed -e '/logout/ i echo "merde, we'\''re nearly done\ncopy'\''n'\''paste the following\n"' \
                 -e 's/^/echo "/' \
                 -e 's/\$/\\$/g' \
                 -e 's/\\$/\\\\/' \
                 -e 's/$/"/' \
           >> $Output
          cat >> $Output << "EOF"
echo "
#
# NOTE - serious debuggers don't want to strip so skip
# this copy'n'paste
#
# from now on use the ~/LFS-chroot.sh script to enter
# you'll want to delete some or all of the foreign man pages
# in the /usr/share/man dir - which should be chown root and chmod 755
# Install chapter 7 and then su kernel to install the kernel.
# Don't forget to set a root password!
EOF
if ! $as_root; then
  cat >> $Output << "EOF"
# Finally - change #!/tools/bin/bash to #!/bin/bash in /usr/sbin/installpkg
#"
EOF
else
  echo "#\"" >> $Output
fi
        fi
    ;;
    sysklogd)
        if ! $as_root; then
        # fix the Make file to use the install wrapper and not the default install bin
          GetCommands \
           | awk '{if ($NF == "install" && $1 == "make") $1 = "  make INSTALL=install"; print $0}' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    systemd) # update the version in the configure section
          GetInternalCommands systemdComms  >> $Output
    ;;
    sysvinit)
        if [ "$SYSTEMD" = yes ]; then
          GetInternalCommands sysvinitComms >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    tar)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/bindir=\/bin/bindir=\/usr\/bin --libexecdir=\/usr\/lib\/tar/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    texinfo)
        # tries and fails to rebuild /usr/share/info/dir
        GetCommands \
         | sed -e '/make TEXMF=/d' \
               -e '/pushd/,/popd/d' \
         >> $Output
    ;;
    util-linux)
        if [ "$Chapter" = chapter06 ]; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/\.\/configure/\.\/configure --disable-login \\\n\              --disable-nologin \\\n\              --enable-mesg \\\n\              --with-systemdsystemunitdir=\/usr\/lib\/systemd\/system/' \
             >> $Output
          else
            GetCommands >> $Output
          fi
        else # ch5
            GetCommands >> $Output
        fi
    ;;
    vim)
        if [ "$Chapters" != update ]; then
          GetCommands \
           | sed -e 's/make test/make -j1 test/' \
                 -e '/:options/d' \
           >> $Output
        else                         # don't need to re-create the /etc/vimrc file
          GetCommands \
           | sed -e 's/make test/make -j1 test/' \
                 -e '/ln -sv vim \/usr\/bin\/vi/,/:options/d' \
           >> $Output
        fi
    ;;
    xz)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/prefix=\/usr/prefix=\/usr --libdir=\/usr\/lib/' \
                 -e '/mv -v/,/ln -svf/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    zlib)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e '/mv -v/,/ln -sfv/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    *)
        GetCommands \
        >> $Output
        return_val=$?
        if [ "$return_val" -eq $RETURN_PARAM ]; then # no build file
          echo "No build file available in ${LFS}${sourcedir}/pkguser"
          echo "Please place the build file there"
          exit 1
        fi
    ;;
esac
} # end WriteScript

cleanstart () {
# $1 is the script name to delete. Can be all
if [ "$1" = all ]; then
  scriptToDelete="$ch6asroot $ch6chroot $ch5script $ch6script $ch8script LFS-chroot.sh"
elif [[ "$1" = chapter05 || "$1" = chapter08 || "$1" = update ]]; then
  scriptToDelete=${1}.sh
elif [ "$1" = chapter06 ]; then
  scriptToDelete="$ch6asroot $ch6chroot $ch6script LFS-chroot.sh"
fi
for Script in $scriptToDelete; do
  for loc in $LFS ~/; do
    if [ -e $loc/$Script ]; then rm $loc/$Script; fi
  done
done
} #end cleanstart

Start () {
cleanstart $WHICH_CHAPTER
local bookdir=$1
local book_version=$2
#
REPODIR=${bookdir}/$book_version
# build the requested chapters
reqChaps=$WHICH_CHAPTER
if [ "$reqChaps" = all ]; then reqChaps="chapter05 chapter06 chapter08"; fi
for Chapters in $reqChaps; do
    case $Chapters in
       chapter05)
          Output=${LFS}/${ch5script}
          Chapter=chapter05
       ;;
       chapter06)
          Output=${LFS}/${ch6script}
          Chapter=chapter06
       ;;
       chapter08)
          Output=${LFS}/${ch8script}
          Chapter=chapter08
       ;;
       update)
          Output=${LFS}/${updateScript}
          Chapter=chapter06
       ;;
    esac
  Header # set the header values
  for Name in $( awk -F\" '/href/ && !/<!--/ {gsub(/\.xml/,"");print $(NF -1)}' ${REPODIR}/${Chapter}/${Chapter}.xml ); do
    if [[ "$BOOK_VERSION" == BOOK && ("$Name" == systemd || "$Name" == dbus) ]]; then # these are no longer in BOOK
      :
    else
      if [ "$Name" = eudev ]; then
        if [ "$SYSTEMD" = yes ]; then Name="systemd"; fi # systemd installed in place of eudev
      fi
      FuncName=$( echo $Name | sed -e s/-//g ) # no - allowed in bash names
      PkgName=$( echo $Name | sed -e s/pass.$// -e s/-$// )
      SrcName=$PkgName-
      CmdName=$Name
# Output file is changed in chapter06, so need to reset it
      case $Chapters in
         chapter05)
            Output=${LFS}/${ch5script}
            Chapter=chapter05
         ;;
         chapter06)
            Output=${LFS}/${ch6script}
            Chapter=chapter06
         ;;
         chapter08)
            Output=${LFS}/${ch8script}
            Chapter=chapter08
         ;;
         update)
            Output=${LFS}/${updateScript}
            Chapter=chapter06
         ;;
      esac
      case $PkgName in
        changingowner)
            : # can't deal with this in chapter05
        ;;
        chroot)
            if [ "$Chapters" != update ]; then
              Output=$LFS/${ch6chroot}
# if you log out or reboot you need to mount the kernelfs again
# so include some conditionals to look after this
              cat $LFS/${ch6asroot} \
              | awk '/mount -v/ { printf "if [ \"$(grep -q \""$NF"\" /proc/mounts;echo $?)\" != \"0\" ]; then\n  "$0"\nfi\n"}' \
              >> $Output
              Function
            fi
        ;;
        createfiles)
            if [ "$Chapters" != update ]; then
              Function
            # Now have a base file structure so add pkguser
              if ! $as_root; then
                pkguser
              else
                copypkguserbin # add listpkg and necessary files
              fi
            fi
        ;;
        creatingdirs)
            if [ "$Chapters" != update ]; then
              Function
            else
              cleanPkgDir
              update_pkguser # add some files to the tools dir
            fi
        ;;
        expect)
            SrcName=expect5
            Function
        ;;
        fstab) # can't deal with this here - chapter7
            :
        ;;
        introduction|toolchaintechnotes|generalinstructions|pkgmgt|aboutdebug)
            : # don't need any of these
        ;;
        kernfs)
            if [ "$Chapters" != update ]; then
              Output=$LFS/${ch6asroot}
              Function
            fi
        ;;
        libstdc++)
            SrcName=gcc-
            Function
        ;;
        linux-headers|kernel)
            SrcName=linux-
            Function
        ;;
        pkgconfig)
            PkgName=pkg-config
            CmdName=pkg-config
            SrcName=pkg-config-
            Function
        ;;
        procps)
            CmdName=procps-ng
            SrcName=procps-ng-
            Function
        ;;
        revisedchroot)
            if [ "$Chapters" != update ]; then
              Output=~/LFS-chroot.sh
            # use this once LFS chapter06 is done, again conditionals added
              cat ${LFS}/${ch6asroot} \
              | awk '/mount -v/ {printf "if [ \"$(grep -q \""$NF"\" /proc/mounts;echo $?)\" != \"0\" ]; then\n  "$0"\nfi\n"}' \
              >> $Output
              WriteScript
            fi
        ;;
        strippingagain)
            if [ "$Chapters" != update ]; then
              Function
            fi
        ;;
        systemd)
            Function
            if [[ "$SYSTEMD" = yes && "$BOOK_VERSION" != systemd ]]; then
# add dbus after systemd
              for sysFile in dbus; do
                FuncName=$sysFile
                PkgName=$sysFile
                SrcName=$sysFile-
                Function
              done
            fi
        ;;
        tcl)
            SrcName=tcl8
            Function
        ;;
        vim) # if updating then build the kernel after vim
              Function
              if [ "$Chapters" = update ]; then
                FuncName=kernel
                PkgName=kernel
                SrcName=linux-
                CmdName=kernel
                Chapter=chapter08
                Function
              fi
        ;;
        xml-parser)
              SrcName=XML-Parser-
              Function
        ;;
        *)
            if [[ "$Chapter" == chapter08 && "$PkgName" == grub ]]; then #want the grub in chapter06 but not the one in chapter08
              :
            else
              Function
            fi
        ;;
      esac
    fi
  done
done
#
arrangeOrder () {
# $1 is the script to arrange
tmpfile=/tmp/$(date +%d%B%Y_%H:%M)tmp.file
IFS=' ' # set the separator to a space
if [ "$1" = all ]; then
  scriptToArrange="${LFS}/${ch6asroot} ${LFS}/${ch6chroot} ${LFS}/${ch5script} ${LFS}/${ch6script} ${LFS}/${ch8script}"
elif [ "$1" = chapter05 ]; then
  scriptToArrange=${LFS}/${ch5script}
elif [ "$1" = chapter06 ]; then
  scriptToArrange="${LFS}/${ch6asroot} ${LFS}/${ch6chroot} ${LFS}/${ch6script}"
elif [ "$1" = chapter08 ]; then
  scriptToArrange="${LFS}/${ch8script}"
elif [ "$1" = update ]; then
  scriptToArrange="${LFS}/${updateScript}"
fi
for scrpt in $scriptToArrange; do
  Output=$scrpt
# match the start line for each function and output it
  awk '/_\ \(\)\ \{/ {print $1}' $Output >> $tmpfile #write to a temp file
#
# you have an opportunity to reset the function order or drop functions here
#
  while read eachFunc; do
    if [[ "$WHICH_CHAPTER" != update ]]; then
      if [[ "$SYSTEMD" = yes ]]; then # don't need sysklogd and sysvinit
        if [[ "$eachFunc" = sysklogd_ || "$eachFunc" = sysvinit_ ]]; then
          : # don't write it
        else
          echo $eachFunc >> $Output
        fi
      else # not systemd
        if [[ "$BOOK_VERSION" = BOOK ]]; then # ignore dbus 
          if [[ "$eachFunc" = dbus_ ]]; then
            : # don't write it
          else 
            echo $eachFunc >> $Output
          fi
        else
          $eachFunc >> $Output
        fi
      fi
    else # don't update coreutils, shadow and systemd. They are reinstalled in BLFS
      case $eachFunc in
          coreutils_|shadow_|attr_|acl_|dbus_|gperf_|expat_|intltool_|libcap_|xmlparser_|systemd_)
                   continue
          ;;
          *)
                   if [[ "$SYSTEMD" = yes && ( "$eachFunc" = sysklogd_ || "$eachFunc" = sysvinit_) ]]; then
                     continue
                   else
                     echo $eachFunc >> $Output
                   fi
          ;;
      esac
    fi
  done < $tmpfile
  rm $tmpfile
  chmod 700 $Output
done
} # end arrangeOrder
#
arrangeOrder $WHICH_CHAPTER
#
# strip the LFS bit from all but chapter05 scripts
if [ "$WHICH_CHAPTER" = chapter06 ]; then
  sed -e 's@BuildLog='$LFS'@BuildLog=@' -i ${LFS}/${ch6script}
elif [ "$WHICH_CHAPTER" = chapter08 ]; then
  sed -e 's@BuildLog='$LFS'@BuildLog=@' -i ${LFS}/${ch8script}
elif [ "$WHICH_CHAPTER" = all ]; then
  sed -e 's@BuildLog='$LFS'@BuildLog=@' -i ${LFS}/{${ch6script},${ch8script}}
elif [ "$WHICH_CHAPTER" = update ]; then
  sed -e 's@BuildLog='$LFS'@BuildLog=@' -i ${LFS}/${updateScript}
fi
# remove all make checks from chapter05 
if [[ "$WHICH_CHAPTER" = chapter05 || "$WHICH_CHAPTER" = all ]]; then
  sed -e '/make check/d' \
      -e '/make -j1 check/d' \
      -e '/make RUN_EXPENSIVE_TESTS=yes check/d' \
      -e '/TZ=UTC make test/d' \
      -e '/make test/d' \
      -i ${LFS}/${ch5script}
fi
#check if tests requested for chapter06 and update
if [[ "$WHICH_CHAPTER" = chapter06 || "$WHICH_CHAPTER" = all || "$WHICH_CHAPTER" = update ]]; then
  scriptFile=${LFS}/${ch6script}
  if [ "$WHICH_CHAPTER" = update ]; then scriptFile=${LFS}/${updateScript}; fi
  if [ "$TESTS" = no ]; then
    sed -e '/make -k check 2>&1 | tee glibc-check-log/d' \
        -e '/grep Error glibc-check-log/d' \
        -e '/make check/d' \
        -e '/make -j1 check/d' \
        -e '/make -k check/d' \
        -e '/make -kj1 check/d' \
        -e '/make -k -j1 check/d' \
        -e '/make check 2>&1 | tee gmp-check-log/d' \
        -e "/awk '\/tests passed\/{total+=\$2} ; END{print total}' gmp-check-log/d" \
        -e '/ulimit -s 32768/d' \
        -e '/..\/gcc-'"${gccvers}"'\/contrib\/test_summary/d' \
        -e '/make NON_ROOT_USERNAME=nobody check-root/d' \
        -e '/echo "dummy:x:1000:nobody" >> \/etc\/group/d' \
        -e '/bash tests\/run.sh --srcdir=\$PWD --builddir=\$PWD/d' \
        -e '/chown -Rv nobody ./d' \
        -e '/su nobody -s \/bin\/bash -c "PATH=\$PATH make check"/d' \
        -e '/su nobody -s \/bin\/bash -c \"make RUN_EXPENSIVE_TESTS=yes check\"/d' \
        -e '/su nobody -s \/bin\/bash -c "make tests"/d' \
        -e "/sed -i '\/dummy\/d' \/etc\/group/d" \
        -e '/make test/d' \
        -e '/make -k test/d' \
        -e '/make -j1 test/d' \
        -i $scriptFile
  fi
#remove making all the locales in glibc as the required ones have been installed
  sed -e '/make localedata\/install-locales/d' \
      -i $scriptFile
fi
#
if [[ "$WHICH_CHAPTER" = chapter05 || "$WHICH_CHAPTER" = all ]]; then
# set lfs as owner of chapter05 script
  chown lfs ${LFS}/${ch5script}
# create the build dir for chapter05.sh and set owner to lfs
  if [ ! -d ${LFS}${builddir05} ]; then
    mkdir -pv ${LFS}${builddir05}
    chown lfs ${LFS}${builddir05}
  else
    chown lfs ${LFS}${builddir05}
  fi
fi
} # end Start
#
# main program  - call the functions
#
if $display_menu; then
  configEdit # option to change the config file
  source $cfg # maybe config edited - update the values
fi
# check BOOK_VERSION and SYSTEMD
if [[ "$BOOK_VERSION" = systemd && "$SYSTEMD" = no ]]; then
  echo "requested book is systemd so SYSTEMD set to yes"
  SYSTEMD="yes"
fi
#
as_root=false
if [ "$AS_ROOT" = yes ]; then as_root=true; fi
#
# set up the script filenames
# first initialize them to null
ch6asroot=""
ch6chroot=""
ch5script=""
ch6script=""
ch8script=""
updateScript=""
WHICH_CHAPTER=$(echo ${WHICH_CHAPTER,,*}) # make sure it's lower case
if [ "$WHICH_CHAPTER" = chapter05 ]; then
  ch5script="chapter05.sh"
elif [ "$WHICH_CHAPTER" = chapter06 ]; then
  ch6asroot="chapter06-asroot.sh"
  ch6chroot="chapter06-chroot.sh"
  ch6script="chapter06.sh"
elif [ "$WHICH_CHAPTER" = chapter08 ]; then
  ch8script="chapter08.sh"
elif [ "$WHICH_CHAPTER" = all ]; then
  ch6asroot="chapter06-asroot.sh"
  ch6chroot="chapter06-chroot.sh"
  ch5script="chapter05.sh"
  ch6script="chapter06.sh"
  ch8script="chapter08.sh"
elif [ "$WHICH_CHAPTER" = update ]; then
  updateScript="update.sh"
else
  echo "Invalid value for WHICH_CHAPTER. $WHICH_CHAPTER not allowed"
  echo "Should be chapter05, chapter06, chapter08, all or update"
  echo "Exiting now"
  exit 1
fi
#
# get the book
#
bookDir=$LFS_BOOK_LOC_DIR
if [ ! -d $bookDir ]; then mkdir -pv $bookDir; fi
#
if [ "$BOOK" = svn ]; then
  GetSvnUrl # make sure the svn url is set
  if [ "$BOOK_VERSION" != blank ]; then #check if the requested book is present locally
    ChkLocalBook $bookDir $version
    SetLFSBook
  else #version set to blank so ask for which book
    WhichLFSBook # choose which LFS version to download the xml files
    # check if the requested book is already present locally
    ChkLocalBook $bookDir $version
  fi
  CleanLocalREPO $bookDir $version
  CheckoutSVN $bookDir $version # svn the requested book xml files
else  # local book
  if [ "$BOOK_VERSION" != blank ]; then
    ChkLocalBookExists $bookDir
    return_val=$?
    if [ "$return_val" -eq $RETURN_PARAM ]; then # no local book found
      echo "The requested book was not found at $bookDir/"
      echo "Change the location or svn it. Exiting now"
      exit 1
    else
      LocalBook  # set values for locally stored book xml
    fi
  else
    WhichLFSBook
    # check if the requested book is already present locally
    ChkLocalBook $bookDir $version
  fi
fi
DumpCommands $REPO $bookDir $version #parse the LFS xml
#
# unpack the pkguser file
#
unpackpkguser $PKGUSERFILE
return_val=$?
if [ "$return_val" -eq $RETURN_PARAM ]; then # pkguser file not present
  echo "Package user file $PKGUSERFILE not found in ${LFS}${sourcedir}"
  echo "Please place it there in order to continue"
  echo "Exiting now"
  exit 1
fi
#
# get the sources
# first set the proxy values - assumes port 3128
#
ipadd=$(ip addr | grep 192 | awk '{print $2}' | awk -F\/ '{print $1}')
proxyset=http://${ipadd}:3128/
http_proxy=$proxyset
ftp_proxy=$proxyset
all_proxy=socks://${ipadd}:3128/
https_proxy=$proxyset
wgetopts="-e use_proxy=yes -e http_proxy=$http_proxy -e ftp_proxy=$ftp_proxy"
#
version=${version%/} # remove any trailing /
SourceDir=${SOURCEDIR}/${version}
sourceloc=${sourcedir}/${version} # location wrt lfs system
WgetList=${SourceDir}/${wgetlist}
downloadSrc=false
if [ "$SOURCES" = download ]; then
  downloadSrc=true 
  if [ ! -d $SourceDir ]; then install -v -m0755 -d $SourceDir; fi
  if [ "$CLEAN_SRC_DIR" = yes ]; then CleanSourceDir $SourceDir $WgetList; fi
# check if src dir is not empty and the wgetlist file is already in place
  if [[ "$(ls -A $SourceDir)" && -e $WgetList ]]; then
    ChkSrcPresent $SourceDir $WgetList # check for src files present
    ret_val=$?
    if [ $ret_val -eq 0 ]; then # all files are present
      echo "You requested 'download' for the sources"
      echo "but they are already present in $SourceDir"
      echo "Continuing without downloading the sources."
      downloadSrc=false
    fi
  fi
  if $downloadSrc; then
    echo "Will use wget to download the sources"
    if hash wget 2>/dev/null; then
       GetSource $version $SourceDir $WgetList $bookDir # download LFS sources
    else
       echo "The host does not have wget installed."
       echo "Please install it in order to download the sources."
       echo "Exiting now."
       exit 1
    fi
  fi
  ChkEmptySrcFiles $SourceDir #check for failed downloads
  return_val=$?
  if [ "$return_val" -eq $RETURN_PARAM ]; then
    echo "Empty source files found in $SourceDir"
    echo "You need to download these and place them in $SourceDir"
    echo "before running the scripts"
  fi
else # sources are local
  echo "Checking if sources are in $SourceDir"
  if [ ! -d $SourceDir ]; then
    echo "You have said that the sources are local but"
    echo "directory $SourceDir does not exist"
    echo "Change the config file to make SOURCES = 'download'"
    echo "or download them yourself and place in $SourceDir"
    echo "Will continue to write the requested script(s)."
  fi 
  if [ ! -e $WgetList ]; then
    echo "No $wgetlist file present in $SourceDir"
    echo "Won't be able to check if LFS sources exist"
  else
    ChkSrcPresent $SourceDir $WgetList # check for src files present
    ret_val=$?
    if [ $ret_val -eq $RETURN_PARAM ]; then 
      echo "Not all requested files in $WgetList have been downloaded"
      echo "You will have to download those that are missing and place them in $SourceDir"
      echo "Do you wish to continue? (Y/n)"
      read reply
      case $reply in
        [yY]|[yY][Ee][Ss])
          echo "okay continue"
        ;;        
        [nN]|[nN][Oo])
          echo "Exiting now"
          exit 1
        ;;        
        *)   
          echo "okay continue"
        ;;        
      esac
    fi
  fi
fi
if [ -d $SourceDir ]; then # source dir exists
  # get the required package versions
  if [ "$SYSTEMD" = yes ]; then
    rtrvers=""
    GetPkgVersion $SourceDir dbus- tar
    dbusvers=$rtrvers
    if [ ! -z $dbusvers ]; then echo "dbus version is $dbusvers"; fi
  fi
  rtrvers=""
  GetPkgVersion $SourceDir gcc- tar
  gccvers=$rtrvers
  if [ ! -z $gccvers ]; then echo "gcc version is $gccvers"; fi
  rtrvers=""
  GetPkgVersion $SourceDir perl- tar
  perlvers=$rtrvers
  if [ ! -z $perlvers ]; then
    echo "perl version is $perlvers"
  else # try a different source loc
    GetPkgVersion $LFS/sources/BOOK perl- tar
    perlvers=$rtrvers
    if [ ! -z $perlvers ]; then echo "perl version is $perlvers"; fi;
  fi
  rtrvers=""
  GetPkgVersion $SourceDir systemd- tar
  systemdvers=$rtrvers
  if [ ! -z $systemdvers ]; then echo "systemd version is $systemdvers"; fi
  rtrvers=""
#GetPkgVersion $SourceDir gettext- tar
#gettextvers=$rtrvers
#if [ ! -z $gettextvers ]; then
#  echo "gettext version is $gettextvers"
#else
#  echo "*** Warning *** the /usr/share/doc/gettext dir in the configure script won't be set correctly because could not get the gettext version. Edit it yourself in chapter06.sh."
#fi
#
else
  echo "Source dir $SourceDir doesn't exist. Can't get package versions"
fi
if [[ "$WHICH_CHAPTER" = chapter08 || "$WHICH_CHAPTER" = all ]]; then
  if [[ -d ${LFS}/${lfscommands}/chapter08 && -d $SourceDir ]]; then
    GetLinuxVersion $SourceDir ${LFS}/${lfscommands}/chapter08 # may have downloaded a later version than that in the book
    ret_val=$?
    if [ $ret_val -eq $RETURN_PARAM ]; then
      echo "**Warning** - value of Linux Src version not set"
      echo "Will not be able to compare the source version and the book version"
    else
      echo "Linux version of the src file is $linuxvers"
      echo "Linux version from the commands is $linuxcomvers"
    fi
  else
    echo "Won't be able to compare the linux src version with the linux version from the $lfscommands file"
  fi
fi
Start $bookDir $version # build the scripts

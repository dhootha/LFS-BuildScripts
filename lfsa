#!/bin/bash
#
LFS=$LFS
if [[ ! -d $LFS || "$LFS" = "" ]]; then
  echo "'$LFS' is not a directory"
  echo "do: export LFS=/mnt/lfs"
  echo
  exit 1
fi

# make sure there is a tools dir, and a symlink to it
if [ -e $LFS/tools -a ! -d $LFS/tools ]; then
  echo "$LFS/tools is not a directory"
  mv -v $LFS/tools $LFS/tools.backup
  echo "moved to $LFS/tools.backup"
  echo "create directory $LFS/tools"
  install -vd $LFS/tools
fi
if [ "$LFS/tools" != "$( ls -l /tools | awk '{print $NF}' )" ]; then
  echo "/tools is not a symlink to $LFS/tools"
  echo ""
  echo "as root, do:"
  echo ""
  echo " ln -s $LFS/tools /tools"
  exit 1
fi
# repository will be for LFS
REPO="LFS"
cfg=$1 # name of the config file, if present
if [ ! -z $cfg ]; then # config filename given
  if [ ! -e $cfg ]; then # doesn't exist - exit
    echo "If you give the config filename it must exist"
    echo "Exiting now"
    exit 1
  else
    display_menu=false
  fi
else
  display_menu=true
  cfg=~/LFS.conf
fi
DumpedCommands=${LFS}/lfs-commands
Dumpedhtml=${LFS}/lfs-html
wgetlist="wget-list" # name of the file containing all the source URLs
WgetOpts="" # Options for wget, e.g. proxy settings etc
RETURN_PARAM=251  # return parameter from a function on error
#
# these are relative to newly installed lfs ( i.e. without $LFS prefix )
sourcedir=/sources
builddir05=/build # chapter 5 build dir
PkgUserDir=/usr/src/core # all installed packages sit under here
BuildLog=$LFS/LFS-buildlog.log # keep a record of packages and times
if [ ! -e $BuildLog ]; then
  touch $BuildLog
  chown lfs:lfs $BuildLog #make lfs the owner
fi
SOURCEDIR=${LFS}${sourcedir}
#initialize the config variables
TZ=$TZ
PAPER_SIZE=$PAPER_SIZE
LFS_BOOK_LOC_DIR=$HOME/LFS_SVN/$REPO # def local dir for the downloaded book xml
SVN_URL="svn://svn.linuxfromscratch.org/$REPO/" #svn url
BOOK_VERSION=$BOOK_VERSION
SOURCES=$SOURCES
BOOK=$BOOK
PKGUSERFILE=$PKGUSERFILE
TESTS=$TESTS
MAKE_KERNEL=$MAKE_KERNEL # "no" -  stop at makeproper, "yes" - use a .config and make
AS_ROOT=$AS_ROOT # 'no' install as package user, 'yes' install as root
SYSTEMD=$SYSTEMD # 'yes' use systemd, 'no' use sysvinit for control
if [ -e $cfg ]; then
  source $cfg # exists so source it
else
  touch $cfg #cfg is new
  if [ -z $TZ ]; then #null
    TZ="America/Chicago"
  fi
  if [ -z $PAPER_SIZE ]; then #null
    PAPER_SIZE="letter"
  fi
  if [ -z $BOOK ]; then
    BOOK="svn"
  fi
  if [ -z $BOOK_VERSION ]; then
    BOOK_VERSION="blank"
  fi
  if [ -z $SOURCES ]; then
    SOURCES="download"
  fi
  if [ -z $PKGUSERFILE ]; then
    PKGUSERFILE="pkguser.tar.xz"
  fi
  if [ -z $TESTS ]; then #null
    TESTS="no"
  fi
  if [ -z $MAKE_KERNEL ]; then #null
    MAKE_KERNEL="no"
  fi
  if [ -z $AS_ROOT ]; then #null
    AS_ROOT="no"
  fi
  if [ -z $SYSTEMD ]; then #null
    SYSTEMD="no"
  fi

# store the values in the new config file
  echo "TZ=$TZ" | tee $cfg 
  echo "PAPER_SIZE=$PAPER_SIZE" | tee -a $cfg
  echo "LFS_BOOK_LOC_DIR=$HOME/LFS_SVN/$REPO" | tee -a $cfg
  echo "SVN_URL=svn://svn.linuxfromscratch.org/$REPO/" | tee -a $cfg
  echo "BOOK_VERSION=$BOOK_VERSION" | tee -a $cfg
  echo "SOURCES=$SOURCES" | tee -a $cfg
  echo "BOOK=$BOOK" | tee -a $cfg
  echo "PKGUSERFILE=$PKGUSERFILE" | tee -a $cfg
  echo "TESTS=$TESTS" | tee -a $cfg
  echo "MAKE_KERNEL=$MAKE_KERNEL" | tee -a $cfg
  echo "AS_ROOT=$AS_ROOT" | tee -a $cfg
  echo "SYSTEMD=$SYSTEMD" | tee -a $cfg
fi
#
# functions
#
configEdit () {
tempfile1=dialog_1
tempfile2=dialog_2
tempfile3=dialog_3
DIALOG=dialog # could set to gui dialog - xdialog, if availale
#test -n "$DISPLAY" && DIALOG=xdialog
# delete temp files on exit
trap "rm -f $tempfile1 $tempfile2 $tempfile3" 0 1 2 5 15

_edit () {
   items=$(awk -F\= '{print $1,$2}' $cfg)
   $DIALOG --title "" \
          --menu "LFS config file editor:" 0 0 0 $items 2> $tempfile1

   retval=$?
   parameter=$(cat $tempfile1)

   [ $retval -eq 0 ] && tochange=$parameter || return 1
   if [ "$tochange" = TZ ]; then
     display="Enter your local time zone. (If not known, run tzselect)"
   elif [ "$tochange" = PAPER_SIZE ]; then
     display="Probably letter or A4"
   elif [ "$tochange" = LFS_BOOK_LOC_DIR ]; then
     display="Enter the local directory to store the LFS Book"
   elif [ "$tochange" = SVN_URL ]; then
     display="Enter the svn url of the LFS book"
   elif [ "$tochange" = BOOK_VERSION ]; then
     display="LFS book version you want (type blank to get a list). ** Note - if SYSTEMD=yes, then type BOOK here."
   elif [ "$tochange" = BOOK ]; then
     display="svn (or) local (if local the book must be in $LFS_BOOK_LOC_DIR)"
   elif [ "$tochange" = SOURCES ]; then
     display="download (or) local (if local, must be in ${SOURCEDIR}/<book_version>)"
   elif [ "$tochange" = PKGUSERFILE ]; then
     display="tar file containing the package user build files. Default is pkguser.tar.xz"
   elif [ "$tochange" = TESTS ]; then
     display="Chapter 6 tests? Type yes (or) no"
   elif [ "$tochange" = MAKE_KERNEL ]; then
     display="If no, kernel will stop at makeproper. If you want to use a .config, type yes"
   elif [ "$tochange" = AS_ROOT ]; then
     display="If yes, install packages as root. If no, install as package user"
   elif [ "$tochange" = SYSTEMD ]; then
     display="If yes, systemd will control start-up, running and shutdown of the system. If no, will use sysvinit. ** Note - if yes, then set BOOK_VERSION=BOOK **"
   fi
   val=$(awk -F\= -v x=$tochange '$1==x {print $2}' $cfg)
   $DIALOG --clear --title "Change value" \
          --inputbox "$display" 0 0 $val 2> $tempfile2

   $DIALOG --title "Confirmation"  --yesno "Commit ?" 0 0
   case $? in
       0) newval=$(cat $tempfile2)
          if [ "$newval" = "" ]; then
            $DIALOG --infobox "Blank value not allowed" 0 0
            sleep 1
          else
            awk -v x=$tochange -v n=$newval '
               BEGIN {FS=OFS="="}$1==x {$2=n} {print}
               ' $cfg > $cfg.tmp
            mv $cfg.tmp $cfg
          fi
       ;;
       1|255) $DIALOG --infobox "Value not changed" 0 0
              sleep 1
   ;;
   esac
   $DIALOG --textbox $cfg 0 0
}

_main () {
   $DIALOG --title "LFS config file editor" \
           --menu "Please choose an option:" 15 55 5 \
                   1 "View the config file" \
                   2 "Edit config file" \
                   3 "Exit from this menu" 2> $tempfile3

   retv=$?
   choice=$(cat $tempfile3)
   if [ $retv -eq 1 -o $retv -eq 255 ]; then
     echo "cancel pressed - exiting now"
     exit 1
   fi

   case $choice in
       1) $DIALOG --textbox $cfg 0 0
          _main
           ;;
       2) _edit
          _main 
           ;;
       3) return 
           ;;
   esac
}
_main
rm -rf $tempfile1 $tempfile2 $tempfile3 # just to be sure they are deleted
} #end configEdit
#
ChkLocalBook () {
localbookdir=$1
ChkLocalBookExists $localbookdir
    return_val=$?
    if [ "$return_val" -eq $RETURN_PARAM ]; then # requested book not present
      echo "Requested book not present locally. Will svn it"
    else # book present, test if need to svn an update
      ChkLocalBookDetails $localbookdir
      return_val=$?
      if [ "$return_val" -eq $RETURN_PARAM ]; then
        exit 1
      fi
    fi
} # end ChkLocalBook
#
ChkLocalBookExists () {
local bookdir=$1
#
unset BookPath
for BookPath in $( find $bookdir -name index.xml -exec dirname {} ';' )
do
  if [ -e $BookPath/.svn ]; then # a book exists, check the version
    if [ $BOOK_VERSION = "Current_Development" ]; then
      version="BOOK"
    else
      version=$BOOK_VERSION
      case $version in
        */) # okay continue
            :
        ;;
        BOOK) # okay continue
            :
        ;;
        [0-9]*) # not okay, didn't end with /
         version=${version}/
        ;;
      esac
    fi
    if [ "$version" != BOOK ]; then BookPath="$BookPath/";fi # add a / 
    if [ "$BookPath" == "${bookdir}/${version}" ]; then
      return 0 #requested version is present locally
    fi
  fi
done
return $RETURN_PARAM #requested book not present locally
} #end ChkLocalBookExists
#
ChkLocalBookDetails () {
local bookdir=$1
#
if [ "$BOOK_VERSION" = Current_Development -o "$BOOK_VERSION" = BOOK ]; then
  # check the last svn date
  returned_array=( $(LastAccessSvn "$argument") )
  retval=$?
  if [ $retval -eq 0 ]; then # compare last svn date with today's date
    if [ ${returned_array[0]} -eq ${returned_array[1]} ]; then
      echo "The same book has already been downloaded today"
      echo "To use it, set BOOK=local in the config file."
      echo "To download it again, delete ${bookdir}/${BOOK_VERSION}"
      return $RETURN_PARAM
    else
      return 0
    fi
  else
    echo "Could not retrieve date of last svn - no entries file found."
    echo "Will svn it"
    return 0
  fi
else # book is a release version so don't update it
  echo "Requested book is present locally so will use it."
  echo "It is a release version so no update necessary."
  return $RETURN_PARAM
fi
} # end ChkLocalBookDetails
#
CleanLocalREPO () { # del any files in the local directory
local bookdir=$1
if [ -d $bookdir ]; then #local dir exists
  if [ "$(ls -A $bookdir)" ]; then
    rm -rf ${bookdir}/${version} # delete contents of local book dir
  fi
else  # create it
  install -v -d $bookdir
fi
} # end CleanLocalREPO
#
GetSvnUrl () {
if [ "$SVN_URL" = blank ]; then
  SVN_URL="svn://svn.linuxfromscratch.org/LFS/"
fi
} # end GetSvnUrl
#
WhichLFSBook () {
Ignore="bootscripts"
PS3="Please select the book version : "
select TAG in 'Current Development' $( svn ls ${SVN_URL}tags | grep -vE "$Ignore" )
do
  case $TAG in
    '') echo >&2 "Please select a numbered option";;
    Current*)
      type=trunk
      version=BOOK
      BOOK_VERSION="Current_Development"
    ;;
    ?*)
      type=tags
      version=$TAG
      BOOK_VERSION=$TAG
    ;;
  esac
  BOOK_SVN_URL="${SVN_URL}$type/$version"
  echo >&2 "You have selected '$TAG'"
  echo >&2 "$BOOK_SVN_URL"
  PS3="Is this correct? : "
  select confirm in Yes No
  do
    case $confirm in
      '') echo >&2 "Please enter 1 for Yes or 2 for No";;
      ?*) break
    esac
  done
  case $confirm in
    No) PS3="Please select the book version : ";;
# update the config file with the book version
   Yes) awk -v x=BOOK_VERSION -v n=$BOOK_VERSION '
             BEGIN {FS=OFS="="}$1==x {$2=n} {print}
             ' $cfg > $cfg.tmp
             mv $cfg.tmp $cfg
      break
  esac
done
} #end WhichLFSBook
#
SetLFSBook () {
case $BOOK_VERSION in
   Current_Development)
         type=trunk
         version=BOOK
   ;;
   BOOK)
         if [ "$SYSTEMD" = yes ]; then
           type=branches/systemd
         else
           type=trunk
         fi
         version=BOOK
   ;;
   *)
         type=tags
         version=$BOOK_VERSION
   ;;
esac  
} #end SetLFSBook
#
LastAccessSvn () {
local passed_array   # Local variable
local bookdir=$LFS_BOOK_LOC_DIR
if [ "$SYSTEMD" = yes ]; then bookdir=${bookdir}/SYSTEMD; fi
BookLoc=${bookdir}/${version}
if [ -e ${BookLoc}/.svn/entries ]; then #check time of last svn
  EntriesDate=$( stat --printf=%y ${BookLoc}/.svn/entries | awk 'gsub(/-/,"") {printf $1}' )
  date=$(date +'%Y-%m-%d %H:%M:%S') # today's date
  read Y M D h m s <<< ${date//[-: ]/ }
  today=$Y$M$D
  passed_array=( $EntriesDate $today ) # return the last svn date and today
  echo "${passed_array[@]}"
  return 0
else
  return $RETURN_PARAM # no entries file found
fi
} # end LastAccessSvn
#
CheckoutSVN () {
local bookdir=$1
#
Url="${SVN_URL}${type}/${version}"
Tag=$version
#
echo "Will svn the LFS book at $Url"
echo "and place it in ${bookdir}/${Tag}"
svn co $Url ${bookdir}/${Tag} # get the requested book
#
} # end CheckoutSVN
#
LocalBook () {
if [ "$BOOK_VERSION" = Current_Development -o "$BOOK_VERSION" = BOOK ]; then
  if [ "$SYSTEMD" = yes ]; then
    type="branches/systemd"
  else
    type="trunk"
  fi
  version="BOOK"
else
  type="tags"
  version=$BOOK_VERSION
fi
} # end LocalBook
#
DumpCommands () {
local bookdir=$2
#
REPODIR=${bookdir}/${version}
target=$( echo $1 | awk '{print tolower($1)}')
SVNINFO="$(svn info $REPODIR | awk '{printf $0"|"}')"
# Note, tagged | on the end so it can be used as a record separator later
# e.g.
# echo $SVNINFO | awk 'BEGIN{ RS = "|" }; {print $0}'
# will 'reconstitute it
SVNrevision=$( echo $SVNINFO | awk 'BEGIN{ RS = "|" };/Revision/ {print $0}' )
for dir in $DumpedCommands
do
  if [ ! -d $dir ]; then
    install -vd $dir
    install -vd $Dumpedhtml
    touch ${dir}/.revision
  fi
done
for dir in $DumpedCommands
do
  if [ -e "$dir" -a "$SVNrevision" != "$( cat $dir/.revision | awk '/Revision/ {print $0}')" ]; then
    rm -rf $dir
    rm -rf $Dumpedhtml
    install -d $dir
    install -d $Dumpedhtml
    pushd $REPODIR
            make -j1 DUMPDIR=$DumpedCommands BASEDIR=$Dumpedhtml $target dump-commands
            for dir in $DumpedCommands $Dumpedhtml
            do
              echo $SVNINFO | awk 'BEGIN{ RS = "|" }; {print $0}' > ${dir}/.revision
            done
    popd
    break
  fi
done
} # end of DumpCommands
#
CleanSourceDir () {
local srcdir=$1
local wgetlistFile=$2
if [ -d $srcdir ]; then
  if [ "$(ls -A $srcdir)" ]; then
    for File in $( ls $srcdir )
    do
      case $File in
          $wgetlist|md5sums) 
            continue #leave these in the source dir
          ;;
          ?*)
            if [ -f $wgetlistFile ]; then
              if [ "$( grep -q $File $wgetlistFile ; echo $? )" = "1" ]; then
                rm ${srcdir}/${File} # delete the file if in $wgetlist
              fi
            else # no $wgetlist file so clean everything out
              rm ${srcdir}/${File} # remove all the files - brutal
            fi
          ;;
      esac
    done
  fi
else
  rm -rf $srcdir # make sure no file exists
  install -v -m0755 -d $srcdir
  chown -v lfs $srcdir
fi
} #end CleanSourceDir
#
GetSource () {
#
local bookvers=$1
local srcdir=$2
local wgetlistFile=$3
local bookdir=$4
#
if [ "$bookvers" = BOOK ]; then # get sources from the urls in $wgetlist
  if [ ! -d $srcdir ]; then install -v -d $srcdir; fi
    REPODIR=${bookdir}/${bookvers}
    make -j1 -f ${REPODIR}/Makefile -C $REPODIR BASEDIR=$srcdir wget-list md5sums
    md5sums=${srcdir}/md5sums

    pushd $srcdir
      RequiredFiles=$( md5sum --quiet -c $md5sums 2> /dev/null | awk -F\: '!/OK/{printf "%s ",$1}' )
    popd

    for File in $RequiredFiles
    do
      Url=$( grep $File $wgetlistFile )
      case $File in
         lfs-bootscripts*)
             if [ ! -e ${srcdir}/${File} ]; then
              wget $WgetOpts -c $Url -O ${srcdir}/${File}
             fi
         ;;
         ?*)
             wget $WgetOpts -c $Url -O ${srcdir}/${File}
         ;;
      esac
    done
else # use anduin to get the source tarball
  bookvers=${bookvers%/}
  File="lfs-packages-${bookvers}.tar"
  sourceURL="http://anduin.linuxfromscratch.org/sources/LFS/lfs-packages/${File}"
  wget $WgetOpts -c $sourceURL -O ${SOURCEDIR}/${File}
  tar xvf ${SOURCEDIR}/${File} -C $SOURCEDIR
  rm -v ${SOURCEDIR}/${File} # untared so remove it
fi
#set all the sources to owner lfs
chown -R -h lfs:root $srcdir # because chapter05.sh is run as lfs
chmod 755 $srcdir
chmod 644 ${srcdir}/*
#
} #end GetSource
#
ChkSrcPresent () { 
# $1 is the directory to check and $2 is the $wgetlist of files
fileMissing=false
local dirtochk=$1
local wgetlistFile=$2
while read FileUrl; do
  if [[ ${FileUrl:0:1} != '#' ]]; then # ignore file if it has a hash at the start
    filetofind=$( echo $FileUrl | awk -F\/ '{print $NF}' )
    if [ ! -e ${dirtochk}/${filetofind} ]; then 
      echo "file $filetofind not downloaded"
      fileMissing=true
    fi   
  fi
done < $wgetlistFile
if $fileMissing; then 
  return $RETURN_PARAM
else
  return 0
fi
} # end ChkSrcPresent
#
ChkEmptySrcFiles () {
local srcdir=$1
zeroLenFiles=$(ls -l $srcdir | awk '!/^d/&&$5==0 {print $NF}')
len=${#zeroLenFiles}
if [ $len -eq 0 ]; then
  return 0
else
  echo -e "These files are empty:\n$zeroLenFiles"
  return $RETURN_PARAM
fi
} # end ChkEmptySrcFiles
#
GetPkgVersion () {
# $1 is the location of the src package
# $2 is the name of the package
# $3 is the name to trim against - usually tar
local pkgloc=$1
local pkgnm=$2
local trim=$3
local fnd
local fileExt
local pkgvers=""
fnd=$( ls -l $pkgloc | grep ${pkgnm}[0-9].*.tar.*z* | awk '{print $NF}' )
fileExt="${fnd#*${pkgnm}}"
pkgvers="${fileExt%.${trim}*}"
rtrvers=($pkgvers)
} # end GetPkgVersion
#
GetLinuxVersion () {
local srcdir=$1
wgetFile=$2
# first find the version of the downloaded kernel source
linuxfnd=$( ls -l $srcdir | grep ' linux-[0-9]' | awk '{print $NF}' )
linuxExt="${linuxfnd#*-}"
linuxvers="${linuxExt%.tar*}"
# now find the version of the kernel in the blfs commands
while read FileUrl; do
  if [[ ${FileUrl:0:1} != '#' ]]; then # ignore file if it has a hash at the start
    linuxcomfnd=$( echo $FileUrl | awk -F\/ '{print $NF}' | grep ^linux-[0-9] )
    if [ ! -z $linuxcomfnd ]; then break; fi
  fi
done < $wgetFile
linuxcomExt="${linuxcomfnd#*-}"
linuxcomvers="${linuxcomExt%.tar*}"
} # end GetLinuxVersion
#
combineScripts () {
declare -a commands=("${!1}")
declare -a buildWrap=("${!2}")
local combine=""
numc=${#commands[@]}
numb=${#buildWrap[@]}
countc=0 # counter for the combine array
countbl=0 # counter for build lines written
inc=false
#
for (( i=0; i<$numb; i++ ))
do
  case "${buildWrap[i]}" in
    configure_commands*)
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: line
      until [[ ${commands[countg]} == make* ]]; do
        combine[countc++]="  ${commands[countg++]}" # configure commands
        inc=true # found at least one configure command
      done
      if ! $inc; then
        combine[countc++]='  echo "no configure script for this package"'
      fi
      ;;
    make_commands*)
      inc=false
      cont=0 # counter for continuation lines 
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: command
      until [[ "${commands[countg]}" == *install* || "${commands[countg]}" == "cp -v perl cpan"* || "${commands[countg]}" == 'cp -v src/{fstab-decode,killall5} /sbin' ]]; do
         case "${commands[countg]}" in
           *\\) 
            storit[cont++]="${commands[countg++]}"
           ;;
           *)
             if [ $cont -gt 0 ]; then # continuation line found
               for (( l=0; l<$cont; l++ )); do
                 combine[countc++]="  ${storit[l]}"
               done
               combine[countc++]="  ${commands[countg++]}"
               cont=0
             else
               combine[countc++]="  ${commands[countg++]}" # make commands
               inc=true #at least one make command found
             fi
             if [ $countg -eq $numc ]; then # no more commands left
               if [[ "${commands[$countg-1]}" != *make* ]]; then
                 ((countc--))
                 ((countg--))
               fi
               break
             fi
           ;;
         esac
       done
       if ! $inc; then
         combine[countc++]='  echo "no make script for this package"'
       fi
      ;;
    install_commands*)
      inc=false
      foundDoc=false
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: command
      until [[ "${commands[countg]}" != *install* && "${commands[countg]}" != "cp -v perl cpan"* && "${commands[countg]}" != 'cp -v src/{fstab-decode,killall5} /sbin' && $cont -eq 0 ]]; do
        case ${commands[countg]} in
          *install*)
             case "${commands[countg]}" in
               *\\) # cont line so store it
                  case "${commands[countg]}" in
                    *'/usr/share/doc'*) # cont line contains a doc
                        foundDoc=true
                        storit[cont++]="${commands[countg++]}"
                    ;;
                    *) # not a doc so store the line
                        storit[cont++]="${commands[countg++]}"
                    ;;
                  esac
               ;;
               'make'*'=/usr/share/doc'*) # genuine install command
                    combine[countc++]="  ${commands[countg++]}"
                    inc=true
               ;;
               *DOCDIR*) # iproute2 has a DOCDIR with a /usr/share/doc/
                    if [ $cont -gt 0 ]; then # first write out cont lines
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                    fi
                    combine[countc++]="  ${commands[countg++]}"
                    inc=true
                    cont=0
               ;;                    
               *'/usr/share/doc'*) # don't write a doc install
                    ((countg++))
               ;;
               *) # install line so write it out
                    if [ $cont -gt 0 ]; then # first write out cont lines
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                    fi
                    combine[countc++]="  ${commands[countg++]}"
                    inc=true
                    cont=0
               ;;
             esac
          ;;
          "cp -v perl cpan"*) # perl commands in chapter 5
                 combine[countc++]="  ${commands[countg++]}"
                 combine[countc++]="  ${commands[countg++]}"
                 combine[countc++]="  ${commands[countg++]}"
                 inc=true
          ;;
          'cp -v src/{fstab-decode,killall5} /sbin') # sysvinit in systemd
                 for (( l=0; l<6; l++ )); do
                   combine[countc++]="  ${commands[countg++]}"
                 done
                 inc=true
          ;;
          '#'*) # comment line so ignore it
              ((countg++))
          ;;
          *'/usr/share/doc'*) # would have got here because we have a cont line
              cont=0 # doc so don't write it out
              ((countg++))
          ;;
          *) # is a cont line
             case "${commands[countg]}" in
               *\\) # another cont line so store it
                 storit[cont++]="${commands[countg++]}"
               ;;
               *)
                 if ! $foundDoc; then # is not a doc so write it out
                   for (( l=0; l<$cont; l++ )); do
                     combine[countc++]="  ${storit[l]}"
                   done
                   combine[countc++]="  ${commands[countg++]}"
                   cont=0
                   inc=true
                   foundDoc=false
                 else # continuation of a doc line so ignore it
                   cont=0
                   ((countg++))
                 fi
               ;;
             esac
          ;;
         esac
         done
         if ! $inc; then
           combine[countc++]='  echo "no install script for this package"'
         fi
    ;;
    *)
        if [ $i -lt $countbl ]; then
          continue
        else
          combine[countc++]=${buildWrap[i]}
          ((countbl++))
        fi
    ;;
  esac
done
rtr=(${combine[@]})
} # end combineScript
#
getBuild () {
local abuild=""
buildfile=${LFS}${sourcedir}/pkguser/build
if [ ! -e $buildfile ]; then
  return $RETURN_PARAM
else
IFS='
'
abuild=( $( < $buildfile ) )
rtrnBuild=(${abuild[@]})
return 0
fi
} # end getBuild
#
getComms () {
# $1 is the chapter containing the commands
# $2 is the package name
local acom=""
local bcom=""
local localpkgname=$2
chapreq=$1
curfile=${DumpedCommands}/${chapreq}/*-${CmdName}
IFS='
'
acom=( $( < $curfile ) )
case $localpkgname in
     xml-parser) # bunched with perl so remove the perl commands
             ic=0
             foundxml=false
             for tline in ${acom[@]}
             do
               case $tline in
                  'cd XML-Parser'*)
                       foundxml=true
                  ;;
                  *)
                     if $foundxml; then
                       bcom[ic++]=$tline
                     fi
                  ;;
               esac
             done
             rtrnCom=(${bcom[@]})
             return 0
     ;;
     *)
             rtrnCom=(${acom[@]})
             return 0
     ;;
esac
} # end getComms
#
GetCommands () {
#get access to the arrays
rtrnBuild=""
getBuild
return_val=$?
if [ "$return_val" -eq $RETURN_PARAM ]; then # no build file present
  return $RETURN_PARAM
else
buildScripts=(${rtrnBuild[@]})
rtrnCom=""
getComms $Chapter $PkgName
commandScripts=(${rtrnCom[@]})
numclines=${#commandScripts[@]} # # of commands
#
# place commands in output until first configure found
countg=0
contline=0
for line in "${commandScripts[@]}"
do
  case "$line" in
       cp*) # expect has a cp with configure in it
         echo "$line"
         ((countg++))
       ;;
       sed*)
         echo "$line"
         ((countg++))
       ;;
       *configure*|*Configure*) #Perl has Configure!
         countg=$countg-$contline
         break
       ;;
       "perl Makefile.PL"*) # for xml-parser
         break
       ;;
       make*) #begins with make
       break
       ;;
       *)
# if a continuation line, store in cache
         case "$line" in
            *\\)
             cacheit[contline++]="$line"
             ((countg++))
            ;;
            *)
             if [ $contline -gt 0 ]; then # continuation line found
               for (( l=0; l<$contline; l++ )); do
                 echo "${cacheit[l]}"
               done
               echo "$line"
               contline=0
               ((countg++)) # count # of commands written to output
               if [ $countg -eq $numclines ]; then
                 return 0
               fi
             else
               echo "$line"
               ((countg++)) # count # of commands written to output
               if [ $countg -eq $numclines ]; then 
                 return 0 
               fi
             fi
            ;;
          esac
       ;;
  esac
done
#
rtr=""
combineScripts commandScripts[@] buildScripts[@]
scriptOut=(${rtr[@]})
for t in "${scriptOut[@]}"
do
  echo $t
done
if [ $countg -ne $((numclines)) ]; then # output remaining commands
  contin=false # switch for a continuation line
  contline=0   # # of continuation lines found
  iftest=false # test for an if block with a /usr/share/doc in it
  for (( k=$countg; k<$((numclines)); k++ ))
  do
      case ${commandScripts[k]} in
         install*)
                case ${commandScripts[k]} in
                   *'/usr/share/doc'*)
                       case ${commandScripts[k]} in
                          *\\) # a continuation line
                             contin=true
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       cacheit[contline++]=${commandScripts[k]}
                       contin=true
                   ;;
                   *) # install but not a doc or a cont line
                       echo ${commandScripts[k]}
                   ;;
                esac
         ;;
         if*) # starts with if so if a doc, will need to delete the closing fi
                case ${commandScripts[k]} in
                   *'/usr/share/doc'*)
                       iftest=true
                       case ${commandScripts[k]} in
                          *\\) # a continuation line
                             contin=true
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       cacheit[contline++]=${commandScripts[k]}
                       contin=true
                   ;;
                   *) # if test but not a doc or a cont line
                       echo ${commandScripts[k]}
                   ;;
                esac
         ;;
         ln*) # a symlink so write it - e.g. vim73
                echo ${commandScripts[k]}
         ;;
         *'/usr/share/doc'*)
                case ${commandScripts[k]} in
                    *\\) # a continuation line
                       contin=true
                    ;;
                    *)
                       if $contin; then # is a doc, so don't write
                         contin=false
                         contline=0
                       fi
                    ;;
                esac
         ;;
         "fi"*)
                if $iftest; then # end of a doc if test - don't write it
                  iftest=false
                else
                  echo ${commandScripts[k]} # if block is not a doc
                fi
         ;;
         *)
              if ! $iftest; then # commands not within a doc if block
                case ${commandScripts[k]} in
                    *\\) # continuation line, store it
                       cacheit[contline++]=${commandScripts[k]}
                       contin=true
                    ;;
                    *)
                       if [ $contline -gt 0 ]; then # write out continuation line(s)
                         for (( l=0; l<$contline; l++ )); do
                           echo "${cacheit[l]}"
                         done
                         contin=false
                         contline=0
                       fi
                       echo ${commandScripts[k]}
                    ;;
                esac
              fi
         ;;
      esac
  done
fi
return 0
fi
} # end GetCommands
#
Header () {
echo writing the script to: $Output
case "$Chapter" in
     chapter05)
       cat > $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -eq 0 ]; then 
  echo "Please do NOT run this script as root."
  echo "Run it as user lfs."
  exit 1
fi
if [ $(whoami) != "lfs" ]; then echo Please run this script as user lfs. ; exit 1; fi
#
EOF
echo "builddir05=$builddir05" >> $Output
       ;;
     chapter06|chapter08)
       cat > $Output << "EOF"
#!/tools/bin/bash -e
#
if [ $UID -ne 0 ]; then echo Please run this script as root. ; exit 1; fi
#
EOF
echo "PkgUserDir=$PkgUserDir" >> $Output
       ;;
esac
echo "me=\$0
LFS=$LFS
SVNINFO=\"$SVNINFO\"
sourcedir=$sourcedir
sourceloc=$sourceloc
BuildLog=$BuildLog" >> $Output
case "$Chapter" in
     chapter05)
       CreateBuildDir >> $Output
       unpack05 >> $Output
     ;;
     chapter06|chapter08)
       if $as_root; then CreateBuildDirasroot >> $Output; fi
     ;;
esac
} # end Header
#
unpackpkguser () {
cd ${LFS}${sourcedir}
tar Jxf $pkguserFile
cd $LFS
} #end unpackpkguser
#
copypkguserbin () { # when installing as root, may need listpkg
cat >> $Output << "EOF"
copypkguserbin_ () {
FuncName=copypkguserbin
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
cd /tools
EOF
echo "tar vxf \${sourcedir}/${pkguserFile}" >> $Output
cat >> $Output << "EOF"
cd pkguser
if [ "$?" != "0" ]; then
  echo "failed to extract pkguser tar file correctly"
  exit 1
fi
cp -v /tools/pkguser/bin/* /usr/bin/
}
EOF
} # end copypkguserbin
#
pkguser () {
cat >> $Output << "EOF"
pkguser_ () {
FuncName=pkguser
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
cd /tools
EOF
echo "tar vxf \${sourcedir}/${pkguserFile}" >> $Output
cat >> $Output << "EOF"
cd pkguser
if [ "$?" != "0" ]; then
  echo "failed to extract pkguser tar file correctly"
  exit 1
fi
cp ./sbin/* /tools/bin
cp ./usr/sbin/* /tools/bin
if [ $(uname -m) = x86_64 ]; then
  mv /tools/bin/su64 /tools/bin/su
else
  mv /tools/bin/su32 /tools/bin/su
fi
if [ ! -d /etc/pkgusr/skel-package ]; then
  mkdir -p /etc/pkgusr/skel-package
fi
cp -r /tools/pkguser/etc/* /etc/pkgusr/
if [ ! -d /usr/lib/pkgusr ]; then
  mkdir -p /usr/lib/pkgusr
fi
cp /tools/pkguser/lib/* /usr/lib/pkgusr/
cp -v /tools/pkguser/bin/* /usr/bin/
cp -v /tools/pkguser/usr/sbin/* /usr/sbin/
if [ "$(grep -q ^install\: /etc/group;echo $?)" != 0 ]; then
  groupadd -g 9999 install
fi
# make sure pkgusers can write to the logfile
chgrp install $BuildLog
chmod 664 $BuildLog
# set some initial dirs to install and sticky
chown 0:9999 $(cat /tools/pkguser/installdirs.lst)
chmod ug=rwx,o=rxt $(cat /tools/pkguser/installdirs.lst)
#
## Nasty workaround
chgrp install /tools/libexec/pt_chown
chmod 4750 /tools/libexec/pt_chown
## Why the work around?
# Normally Chapter 06 is carried out as root.
# As pkgusers have no root powers they get stuck creating ptys for expect which is used in testsuites
# setting pt_chown suid solves this issue.
# Restricting execution to root and the install group effectivly means you need root
# ( as the only way to get to a pkguser is via su from root )

cat >> /etc/pkgusr/bash_profile << "BashProfile"
#
complete -o default -o nospace -A user su finger pinky
export PkgName=$LOGNAME
if [ -e /usr/src/core/${LOGNAME}/build -a ! -e ~/.${LOGNAME} ]; then
  cd
  bash -e /usr/src/core/${LOGNAME}/build
  exit
fi

BashProfile
install -v -d /usr/src/core/${LOGNAME}
echo "${FuncName}" >> $BuildLog
}
EOF
} # end of pkguser
#
delSrcFile () {
echo "cd \$curdir
cd ..
rm -rf \$curdir"
} # end of delSrcFile
#
Function () {
case $PkgName in
    changingowner|kernfs|chroot)
#
    case $PkgName in
        changingowner)
        Chapter=$(echo $Chapter | sed s/06/05/)
    ;;
    esac
    WriteScript
    return
    ;;
esac
echo "${FuncName}_ () {" >> $Output
#echo "FuncName=$FuncName" >> $Output
case "$Chapter" in
    chapter05)
        echo "FuncName=$FuncName" >> $Output 
        TestBuiltCh5
        case $FuncName in
           adjusting|stripping)
              echo "starttime=\$( date +%s )" >> $Output
           ;;
           *)
echo "PkgName=$PkgName
SrcName=$SrcName
starttime=\$( date +%s )" >> $Output
cat >> $Output << "EOF"
CreateBuildDir $FuncName
EOF
           case $FuncName in
             gccpass1|gccpass2)
                 cat >> $Output << "EOF"
# chapter 5 gcc requires unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.*z* .
done
EOF
            ;;
           esac
echo "unpack05" >> $Output
           ;;
        esac
    ;;
    chapter06|chapter08)
      case $PkgName in
        chroot|kernfs|strippingagain|readjusting|adjusting|creatingdirs|createfiles)
          echo "FuncName=$FuncName" >> $Output
          cat >> $Output << "EOF"
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
EOF
        ;;
        *)
          echo "PkgName=$PkgName" >> $Output
            cat >> $Output << "EOF"
if [ -e "$PkgUserDir/$PkgName/.$PkgName" ]; then
  echo "skipping $PkgName"
  return
fi
EOF
          echo "SrcName=$SrcName" >> $Output
          if ! $as_root; then
cat >> $Output << "EOF"
install -v -d ${PkgUserDir}/${PkgName}
touch ${PkgUserDir}/${PkgName}/build
echo "BuildLog=$BuildLog" > ${PkgUserDir}/${PkgName}/build
cat >> ${PkgUserDir}/${PkgName}/build << "IPS"
set +h
PkgName=$LOGNAME
CUR_DIR=$HOME
EOF
echo "SrcName=$SrcName
sourceloc=$sourceloc" >> $Output
if [ "$Chapter" = chapter08 ];then echo "sourcedir=$sourcedir" >> $Output; fi
          else # building as root
cat >> $Output << "EOF"
CreateBuildDirasroot $PkgName
EOF
          fi
        ;;
      esac
    case $PkgName in
      chroot|revisedchroot|kernfs|strippingagain|readjusting|adjusting|creatingdirs|createfiles)
       ;;
       kernel)
        unpack >> $Output
        ret_val=$?
        if [ $ret_val -eq $RETURN_PARAM ]; then # no .config file found
          echo "***********************************************"
          echo "You set MAKE_KERNEL to yes but the .config file"
          echo "is not in ${LFS}${sourcedir}. Place it there in"
          echo "order to compile the kernel source."
          echo "***********************************************"
        fi
        cat >> $Output << "EOF"
unpack
EOF
       ;;
       *)
        unpack >> $Output
        cat >> $Output << "EOF"
unpack
curdir=$( echo $PWD ) #store the current dir for later deletion
EOF
       ;;
     esac
    ;;
esac
WriteScript
closefunction
} # end of Function
closefunction () {
case "$Chapter" in
    chapter05)
      case $FuncName in
        stripping)
        cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "${FuncName} $unpacktime $elapsedtime" >> $BuildLog
EOF
       ;;
       *)
       cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "${FuncName} $unpacktime $elapsedtime" >> $BuildLog
EOF
       ;;
      esac
       case $PkgName in
           stripping)
            cat >> $Output << "EOF"
echo "removing contents of the build directory"
rm -rf ${LFS}${builddir05}/*
echo "Delete the build dir as root"
echo 
echo "You should now store the /tools dir somewhere on your host"
echo "in case there is a build problem in chapter06"
}
EOF
           ;;
           *)
           cat >> $Output << "EOF"
}
EOF
           ;;
       esac
    ;; #close function for the chapter05.sh script
    chapter06)
       case $PkgName in
           chroot|kernfs|readjusting|adjusting|strippingagain|creatingdirs|createfiles)
             cat >> $Output << "EOF"
echo "${FuncName}" >> $BuildLog
}
EOF
           ;;
           *)
            if ! $as_root; then
             cat >> $Output << "EOF"
touch ~/.${PkgName}
endtime=$( date +%s )
set +e
EOF
            else
             cat >> $Output << "EOF"
touch ${PkgUserDir}/${PkgName}/.${PkgName}
endtime=$( date +%s )
set +e
EOF
            fi
delSrcFile >> $Output
if [ "$PkgName" = glibc ]; then #also delete glibc-build
  echo "rm -rf glibc-build" >> $Output
elif [ "$PkgName" = binutils ]; then #also delete binutils-build
  echo "rm -rf binutils-build" >> $Output
elif [ "$PkgName" = gcc ]; then #also delete gcc-build
  echo "rm -rf gcc-build" >> $Output
fi
           cat >> $Output << "EOF"
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "${PkgName} $unpacktime $elapsedtime" >> $BuildLog
EOF
         if ! $as_root; then
           echo "IPS" >> $Output
           setuplinks # setup any preprocessing commands
           if [ ! -z $links ]; then resolvelinks; fi
           cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName
fi
EOF
           if [ ! -z $links ]; then # preprocessing
cat >> $Output << "EOF"
resolvelinks
EOF
           fi
           cat >> $Output << "EOF"
su $PkgName
if [ ! -e $PkgUserDir/$PkgName/.$PkgName ]; then
  echo "${PkgName} failed"
  exit 1
fi
set +e # in case ldconfig does not exist yet
ldconfig
set -e
EOF
#set required dirs to be install dirs plus some other stuff
          case $PkgName in
            linux-headers) #/usr/include/scsi
              cat >> $Output << "EOF"
chgrp install /usr/include/scsi
chmod g+w,o+t /usr/include/scsi
EOF
            ;;
            glibc) #/usr/share/info/dir plus setuid root pt_chown
              cat >> $Output << "EOF"
chown root:install /usr/share/info/dir
chmod 664 /usr/share/info/dir
chown root /usr/lib/pt_chown
chmod 4755 /usr/lib/pt_chown
chgrp install /usr/include/sys # for libcap
chmod g+w,o+t /usr/include/sys
chgrp install /var/db
chmod g+w,o+t /var/db
EOF
            ;;
            pkg-config) #/usr/share/aclocal
              cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
chgrp install /usr/lib/pkgconfig
chmod g+w,o+t /usr/lib/pkgconfig
EOF
            ;;
            ncurses)
chown 0.0 /etc/ld.so.cache
            ;;
            inetutils) # ping, etc setuid root
              cat >> $Output << "EOF"
chown root /bin/ping*
chmod 4755 /bin/ping*
chown root /bin/traceroute
chmod 4755 /bin/traceroute
chown root /usr/bin/{rcp,rlogin,rsh}
chmod 4755 /usr/bin/{rcp,rlogin,rsh}
EOF
            ;;
            util-linux) # mount setuid root
              cat >> $Output << "EOF"
chown root /bin/{mount,umount}
chmod 4755 /bin/{mount,umount}
chown root:tty /usr/bin/wall
chmod 2755 /usr/bin/wall
if [ -e /lib/systemd ]; then
  chgrp install /lib/systemd # if dbus installed
  chmod g+w,o+t /lib/systemd
  chgrp install /lib/systemd/system
  chmod g+w,o+t /lib/systemd/system
fi
EOF
            ;;
            shadow)
              cat >> $Output << "EOF"
pwconv
grpconv
chown root /bin/{passwd,su}
chmod 4755 /bin/{passwd,su}
EOF
            ;;
            bash) #/usr/share/aclocal
              cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
chown -h bash:bash /bin/sh
EOF
            ;;
            man-db) #/es,it,ru
              cat >> $Output << "EOF"
chgrp install /usr/share/man/es
chgrp install /usr/share/man/es/man*
chgrp install /usr/share/man/it
chgrp install /usr/share/man/it/man*
chmod g+w,o+t /usr/share/man/es
chmod g+w,o+t /usr/share/man/es/man*
chmod g+w,o+t /usr/share/man/it
chmod g+w,o+t /usr/share/man/it/man*
EOF
            ;;
            man-pages)
              cat >> $Output << "EOF"
chown man-pages /usr/share/man/man*
EOF
            ;;
            perl)
echo "case \$(uname -m) in
   x86_64) archi=x86_64-linux
   ;;
   *)      archi=i686-linux
   ;;
esac
chgrp install /usr/lib/perl5/${perlvers}/\$archi
chmod g+w,o+t /usr/lib/perl5/${perlvers}/\$archi
chgrp install /usr/lib/perl5/site_perl/${perlvers}
chmod g+w,o+t /usr/lib/perl5/site_perl/${perlvers}
chgrp install /usr/lib/perl5/site_perl/${perlvers}/\$archi
chmod g+w,o+t /usr/lib/perl5/site_perl/${perlvers}/\$archi" >> $Output
            ;;
            xml-parser)
echo "case \$(uname -m) in
   x86_64) archi=x86_64-linux
   ;;
   *)      archi=i686-linux
   ;;
esac
chgrp install /usr/lib/perl5/site_perl/${perlvers}/\$archi/auto
chmod g+w,o+t /usr/lib/perl5/site_perl/${perlvers}/\$archi/auto
chgrp install /usr/lib/perl5/site_perl/${perlvers}/\$archi/auto/XML
chmod g+w,o+t /usr/lib/perl5/site_perl/${perlvers}/\$archi/auto/XML
chgrp install /usr/lib/perl5/${perlvers}/\$archi/perllocal.pod
chmod 664 /usr/lib/perl5/${perlvers}/\$archi/perllocal.pod" >> $Output
            ;;
            grub)
              cat >> $Output << "EOF"
chgrp install /etc/bash_completion.d
chmod g+w,o+t /etc/bash_completion.d
EOF
            ;;
            udev)
              cat >> $Output << "EOF"
chgrp install /lib/udev/rules.d
chmod g+w,o+t /lib/udev/rules.d
chgrp install /lib/firmware
chmod g+w,o+t /lib/firmware
EOF
            ;;
            systemd)
              cat >> $Output << "EOF"
chgrp install /lib/udev/rules.d
chmod g+w,o+t /lib/udev/rules.d
chgrp install /etc/udev/rules.d
chmod g+w,o+t /etc/udev/rules.d
chgrp install /usr/share/pkgconfig
chmod g+w,o+t /usr/share/pkgconfig
chgrp install /usr/share/polkit-1 # for polkit
chmod g+w,o+t /usr/share/polkit-1
chgrp install /usr/share/polkit-1/actions
chmod g+w,o+t /usr/share/polkit-1/actions
chgrp install /etc/xdg # for at-spi2-core
chmod g+w,o+t /etc/xdg
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
chgrp install /lib/systemd/system/shutdown.target.wants
chmod g+w,o+t /lib/systemd/system/shutdown.target.wants
# systemd-detect-virt-install-hook
/usr/sbin/setcap cap_dac_override,cap_sys_ptrace=ep /usr/bin/systemd-detect-virt
EOF
            ;;
            dbus)
              cat >> $Output << "EOF"
if [ "$(grep -q ^messagebus /etc/group; echo $?)" != 0 ]; then
  groupadd -g 18 messagebus
  useradd -c "D-Bus Message Daemon User" -d /var/run/dbus \
        -u 18 -g messagebus -s /bin/false messagebus
fi
chown root:messagebus /usr/lib/dbus-1.0/dbus-daemon-launch-helper
chmod 4750 /usr/lib/dbus-1.0/dbus-daemon-launch-helper
chgrp install /usr/lib/dbus-1.0
chmod g+w,o+t /usr/lib/dbus-1.0
chgrp install /usr/share/dbus-1
chmod g+w,o+t /usr/share/dbus-1
chgrp install /usr/share/dbus-1/services
chmod g+w,o+t /usr/share/dbus-1/services
chgrp install /usr/share/dbus-1/system-services
chmod g+w,o+t /usr/share/dbus-1/system-services
chgrp install /usr/include/dbus-1.0/dbus
chmod g+w,o+t /usr/include/dbus-1.0/dbus
chgrp install /etc/dbus-1/system.d
chmod g+w,o+t /etc/dbus-1/system.d
chgrp install /lib/systemd/
chmod g+w,o+t /lib/systemd/
chgrp install /lib/systemd/system
chmod g+w,o+t /lib/systemd/system
chgrp install /lib/systemd/system/sockets.target.wants
chmod g+w,o+t /lib/systemd/system/sockets.target.wants
chgrp install /lib/systemd/system/multi-user.target.wants
chmod g+w,o+t /lib/systemd/system/multi-user.target.wants
EOF
            ;;
            vim) # man pages
              cat >> $Output << "EOF"
chgrp install /usr/share/man/fr*
chgrp install /usr/share/man/it*
chgrp install /usr/share/man/pl*
chgrp install /usr/share/man/ru*
chmod g+w,o+t /usr/share/man/fr*
chmod g+w,o+t /usr/share/man/it*
chmod g+w,o+t /usr/share/man/pl*
chmod g+w,o+t /usr/share/man/ru*
EOF
            ;;
          esac # end case pkgname
          cat >> $Output << "EOF"
}
EOF
         else
echo "}" >> $Output
         fi # end of as_root test
         ;; #name loop
       esac
    ;; # close chapter06 loop
   chapter08)
      if ! $as_root; then
         cat >> $Output << "EOF"
touch ~/.${PkgName}
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "${PkgName} $unpacktime $elapsedtime" >> $BuildLog
EOF
         echo "IPS" >> $Output
         if [ ! -z $links ]; then resolvelinks; fi
         cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName
fi
EOF
         if [ ! -z $links ]; then # preprocessing
cat >> $Output << "EOF"
resolvelinks
EOF
         fi
         cat >> $Output << "EOF"
su $PkgName
if [ ! -e $PkgUserDir/$PkgName/.$PkgName ]; then
  echo "${PkgName} failed"
  exit 1
fi
set +e # ldconfig might not exist yet
ldconfig
set -e
EOF
         if [ "$SYSTEMD" = no ]; then
           cat >> $Output << "EOF"
rm ${PkgUserDir}/{coreutils/{.coreutils,build},udev/{.udev,build},shadow/{.shadow,build}} # in prep for blfs
EOF
         else
           cat >> $Output << "EOF"
rm ${PkgUserDir}/{coreutils/{.coreutils,build},systemd/{.systemd,build},shadow/{.shadow,build}} # in prep for blfs
EOF
         fi
      else
         cat >> $Output << "EOF"
touch ${PkgUserDir}/${PkgName}/.${PkgName}
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "${PkgName} $unpacktime $elapsedtime" >> $BuildLog
EOF
         if [ "$SYSTEMD" = no ]; then
           cat >> $Output << "EOF"
rm ${PkgUserDir}/{coreutils/.coreutils,udev/.udev,shadow/.shadow} # in prep for blfs
EOF
         else
           cat >> $Output << "EOF"
rm ${PkgUserDir}/{coreutils/.coreutils,shadow/.shadow} # in prep for blfs
EOF
         fi
      fi # end as_root
#
      if [ "$MAKE_KERNEL" = yes ]; then
      # write out the cp commands
        kerneldir=${PkgUserDir}/kernel/linux*
        rtrnCom=""
        CmdName=kernel
        getComms $Chapter $PkgName
        if [ -z $linuxvers ]; then linuxvers=$linuxcomvers; fi # linuxvers not set
        for line in ${rtrnCom[@]}
        do
          case $line in
             "cp -v"*)
                    line=${line#"cp -v "}
                    linout=$(echo "cp -v ${kerneldir}/${line}")
                    echo $linout | sed -e 's/'"$linuxcomvers"'/'"$linuxvers"'/' \
                    >> $Output
              ;;
          esac
        done
        rtrnCom=""
        CmdName=theend
        getComms "chapter09" $PkgName
        for line in ${rtrnCom[@]}
        do
          case $line in
            DISTRIB_CODENAME*)
              echo $line | sed -e 's@<your name here>@John@' \
              >> $Output
            ;;
            *)
              echo $line >> $Output
            ;;
          esac
        done
      fi # end MAKE_KERNEL
      echo "}" >> $Output
    ;;
esac
} #end closefunction
#
setuplinks () { # setup preprocessing
case $PkgName in
    gcc)
        links="/usr/lib/libstdc++.la /usr/lib/libgcc_s.so{,.1} /usr/lib/libstdc++.so{,.6}"
    ;;
    bash)
        links="/bin/bash"
    ;;
    coreutils)
        links="/bin/{cat,echo,false,pwd,stty} /etc/group"
    ;;
    ncurses)
        links="/etc/ld.so.cache"
    ;;
    perl)
        links="/usr/bin/perl"
    ;;
    shadow)
        links="/usr/share/man/man{5/passwd.5,3/getspnam.3} /etc/{passwd,shadow,group,gshadow}{,-}"
    ;;
    sysklogd)
        links="/usr/share/man/man8/sysklogd.8"
    ;;
    udev)
        links="/lib/{firmware,udev,udev/devices,udev/devices/pts}"
    ;;
    *)
        links=""
    ;;
esac
} # end setuplinks
#
resolvelinks () {
# At the beginning of chapter 6 there are symlinks that point to the tools dir
# Trouble is these are owned by root so need to change owner to the package user
echo "resolvelinks () {
for link in $links
do
  if [ -e "\$link" ]; then
    chown -h \$PkgName:\$PkgName \$link # change owner to package user so can overwrite
  fi
done
return
}" >> $Output
} #end resolvelinks
#
CreateBuildDir () {
# only used in chapter 5
cat << "EOF"
CreateBuildDir () {
BuildDir=${LFS}${builddir05}/${1}
if [ ! -e $BuildDir ]; then install -d $BuildDir; fi
cd $BuildDir
CUR_DIR=".."
}
EOF
} #end CreateBuildDir
#
CreateBuildDirasroot () {
cat << "EOF"
CreateBuildDirasroot () {
BuildDirasroot=${PkgUserDir}/${1}
if [ ! -e $BuildDirasroot ]; then install -d $BuildDirasroot; fi
cd $BuildDirasroot
CUR_DIR=".."
}
EOF
} # end CreateBuildDirasroot
#
unpack05 () { # need the LFS bit for chapter05 only
cat << "EOF"
unpack05 () {
starttime=$( date +%s )
cp ${LFS}${sourceloc}/${SrcName}*.* .
cd $(tar vxf ${SrcName}*z* | awk -F\/ 'END{print $1}')

endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
}
EOF
} #end unpack05
unpack () {
case $PkgName in
    glibc)
    cat << "EOF"
unpack () {
starttime=$( date +%s )
cp ${sourceloc}/${SrcName}*.* .
if [ -e ${sourceloc}/tzdata*.tar.*z* ]; then
  cp ${sourceloc}/tzdata*.tar.*z* .
fi
cd $(tar vxf ${SrcName}*z* | awk -F\/ 'END{print $1}')
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
}
EOF
    ;;
    udev)
    cat << "EOF"
unpack () {
starttime=$( date +%s )
cp ${sourceloc}/${SrcName}*.* .
if [ -e ${sourceloc}/udev-lfs*.tar.*z* ]; then
  cp ${sourceloc}/udev-lfs*.tar.*z* .
fi
cd $(tar vxf ${SrcName}*z* | awk -F\/ 'END{print $1}')

endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
}
EOF
    ;;
    kernel)
    cat << "EOF"
unpack () {
starttime=$( date +%s )
cp ${sourceloc}/${SrcName}*.* .
cd $(tar vxf ${SrcName}*z* | awk -F\/ 'END{print $1}')
make mrproper
EOF
if [ "$MAKE_KERNEL" = yes ]; then
  if [ ! -e ${LFS}${sourcedir}/.config ]; then return $RETURN_PARAM; fi
    cat << "EOF"
cp ${sourcedir}/.config .
EOF
fi
    cat << "EOF"
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
}
EOF
   ;;
    *)
    cat << "EOF"
unpack () {
starttime=$( date +%s )
cp ${sourceloc}/${SrcName}*.* .
cd $(tar vxf ${SrcName}*z* | awk -F\/ 'END{print $1}')

endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
}
EOF
   ;;
esac
return 0
} # end unpack
#
TestBuiltCh5 () {
    cat >> $Output << "EOF"
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName"
  return
else
  echo "Building $FuncName"
fi
EOF
} #end TestBuiltCh5
#
WriteScript () {
case $PkgName in
    attr) # present in a systemd version of lfs
        GetCommands \
         | sed -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_BIN_DIR)/d' attr\/Makefile" \
               -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_BIN_DIR)/d' getfattr\/Makefile" \
               -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(PKG_BIN_DIR)/d' setfattr\/Makefile" \
               -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man1\/Makefile" \
               -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man2\/Makefile" \
               -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man3\/Makefile" \
               -e "/make install/i\  sed -i '/\\\\\$(INSTALL) -m 755 -d \\\\\$(MAN_DEST)/d' man\/man5\/Makefile" \
         >> $Output
    ;;
    bash)
       GetCommands \
        | sed -e '/nobody/d' \
              -e '/--login/d' \
        >> $Output

    ;;
    bc)
       GetCommands \
        | sed -e '/echo "quit"/d' \
        >> $Output

    ;;
    binutils)
          # check if the build dir exists
          GetCommands \
          | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
print $0
}' \
          >> $Output
    ;;
    coreutils)
        GetCommands \
        | sed -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
        >> $Output
    ;;
    createfiles)
        # can't start a new shell just yet - it'll stop the script
        GetCommands \
        | sed '/exec \/tools\/bin\/bash --login +h/d' \
        >> $Output
    ;;
    creatingdirs)
        GetCommands \
        | sed -e 's/mkdir -v/mkdir -pv/' \
        >> $Output
    ;;
    e2fsprogs)
        GetCommands \
        | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
              -e 's/cd build/cd e2fsprogs-build/' \
        >> $Output
    ;;
    gawk|flex)
        # gawk-4.0.0's make check has a race condition, so force jobs to 1
        # so does flex-2.5.35
        #
        GetCommands \
        | sed -e 's/check/-j1 check/' \
        >> $Output
    ;;
    gcc)
        GetCommands \
        | sed -e '/ulimit -s/d' \
              -e '/contrib\/test_summary/d' \
              -e "/ln -sv gcc/ a set +e" \
        | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
print $0
}' \
        >> $Output
        echo "set -e" >> $Output
    ;;
    gettext) # update with current version
        GetCommands \
        | sed -e '/--docdir=\/usr\/share\/doc\/gettext/d' \
              -e "/configure --prefix/a\              --docdir=\/usr\/share\/doc\/gettext-${gettextvers}" \
        >> $Output
    ;;
    glibc)
        # set up glibc's timezone
        # + fix the builddir issue
        GetCommands \
        | sed -e '/tzselect/d' \
              -e 's/zic/\/usr\/sbin\/zic/' \
              -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
        | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
print $0
}' \
        | awk '{if ($1 == "mkdir" && $NF =="/etc/ld.so.conf.d")
print "if [ ! -e "$NF" ]; then\n  "$1" -v "$NF"\nfi\n";
else
print $0
}' \
        >> $Output
    ;;
    gmp)
        # if building for 64bit need to remove config for 32
        GetCommands \
        | sed -e '/ABI=32/d' \
        >> $Output
    ;;
    groff)
        GetCommands \
        | sed -e 's/\*\*EDITME<paper_size>EDITME\*\*/'$PAPER_SIZE'/' \
        >> $Output
    ;;
    kbd)
        GetCommands \
        | sed -e 's/\(.*\)&&$/\1/' \
        >> $Output
    ;;
    kernel)
      if [ "$MAKE_KERNEL" = yes ]; then
        GetCommands \
        | sed -e '/make mrproper/,/End of editable block/d' \
              -e '/cp -v arch/,/cp -v .config/d' \
              -e 's/linux-'"${linuxcomvers}"'/linux-'"${linuxvers}"'/' \
        >> $Output
      fi
    ;;
    perl)
        GetCommands \
        | sed -e "/tar xf ..\/XML-Parser-2.41.tar.gz/,/make install/d" \
        >> $Output
    ;;
    procps)
       #
       GetCommands \
        | sed -e '/pushd/,/popd/d' \
        >> $Output
    ;;
    shadow)
        # assume no cracklib support
        # don't install foreign man pages
        # don't set root passwd
        # setup shadow pssswd files
        # delete pwconv and grpconv because cannot lock /etc/passwd
        # do pwconv and grpconv later as root
        GetCommands \
        | sed -e "/sed -i 's@DICTPATH.*@DICTPATH\\\t\/lib\/cracklib\/pw_dict@' \\\\/d" \
              -e '0,/etc\/login.defs/! s/etc\/login.defs//' \
              -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n -e 's\/zh_CN zh_TW\/\/' \\\\\n -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
              -e '/passwd root/d' \
              -e '/pwconv/ i touch /etc/shadow\nchmod 640 /etc/shadow' \
              -e '/grpconv/ i touch /etc/gshadow\nchmod 640 /etc/gshadow' \
              -e '/pwconv/d' \
              -e '/grpconv/d' \
        >> $Output
    ;;
    stripping)
        # strip always exits with 1, so toggle bash's -e flag
        echo "set +e" >> $Output
        GetCommands \
        >> $Output
        echo "set -e" >> $Output
    ;;
    strippingagain)
        GetCommands \
        | sed -e '/logout/ i echo "merde, we'\''re nearly done\ncopy'\''n'\''paste the following\n"' \
              -e 's/^/echo "/' \
              -e 's/\$/\\$/g' \
              -e 's/\\$/\\\\/' \
              -e 's/$/"/' \
        >> $Output
        cat >> $Output << "EOF"
echo "
#
# NOTE - serious debuggers don't want to strip so skip
# this copy'n'paste
#
# from now on use the ~/LFS-chroot.sh script to enter
# you'll want to delete some or all of the foreign man pages
# in the /usr/share/man dir - which should be chown root and chmod 755
# Install chapter 7 and then su kernel to install the kernel.
# Don't forget to set a root password!
# Finally - change #!/tools/bin/bash to #!/bin/bash in /usr/sbin/installpkg
#"
EOF
    ;;
    sysklogd)
       # fix the Make file to use the install wrapper and not the default install bin
       GetCommands \
        | awk '{if ($NF == "install" && $1 == "make") $1 = "  make INSTALL=install"; print $0}' \
        >> $Output
    ;;
    systemd) # update the version in the configure section
       GetCommands \
        | sed -e '/--docdir=\/usr\/share\/doc\/systemd/d' \
              -e 's/--without-python/--without-python --docdir=\/usr\/share\/doc\/systemd-'${systemdvers}'/' \
        >> $Output
    ;;
    texinfo)
        # tries, and fails, to rebuild /usr/share/info/dir
        GetCommands \
        | sed -e '/cd \/usr\/share\/info/,/done/d' \
        >> $Output
    ;;
    vim)
        GetCommands \
        | sed -e 's/make test/make -j1 test/' \
              -e '/:options/d' \
        >> $Output
    ;;
    *)
        GetCommands \
        >> $Output
        return_val=$?
        if [ "$return_val" -eq $RETURN_PARAM ]; then # no build file
          echo "No build file available in ${LFS}${sourcedir}/pkguser"
          echo "Please place the build file there"
          exit 1
        fi
    ;;
esac
} # end WriteScript

cleanstart () {
for Script in chapter{05,06,08,06-asroot,06-chroot}.sh LFS-chroot.sh
do
  for loc in $LFS ~/
  do
    if [ -e $loc/$Script ]; then rm $loc/$Script; fi
  done
done
} #end cleanstart

Start () {
systemdfound=false # in later lfs, udev is installed from systemd source file
cleanstart
local bookdir=$1
#
REPODIR=${bookdir}/$version
#
for Chapter in chapter{05,06,08}
do
  Output=$LFS/${Chapter}.sh
  Header
  for Name in $( awk -F\" '/href/ && !/<!--/ {gsub(/\.xml/,"");print $(NF -1)}' ${REPODIR}/${Chapter}/${Chapter}.xml )
  do
    if [ "$Name" = systemd ]; then
      if [ "$SYSTEMD" = no ]; then
        systemdfound=true
        Name="udev"  # systemd not installed in standard lfs
      fi
    fi
    FuncName=$( echo $Name | sed -e s/-//g ) # no - allowed in bash names
    PkgName=$( echo $Name | sed -e s/pass.$// -e s/-$// )
    SrcName=$PkgName-
    if $systemdfound; then
      SrcName=systemd-
      systemdfound=false
    fi
    CmdName=$Name
    Output=$LFS/${Chapter}.sh
    case $PkgName in
      changingowner|kernfs)
          Chapter=$(echo $Chapter | sed s/05/06/)
          # changingowner is at the end of chapter 5 but needs root privilege so
          # makes sense to shift it into chapter06's 'requires root' script
          Output=$LFS/${Chapter}-asroot.sh
          Function
      ;;
      chroot)
          Output=$LFS/${Chapter}-chroot.sh
          # if you log out or reboot you need to mount the kernelfs again
          # so include some conditionals to look after this
          cat $LFS/${Chapter}-asroot.sh \
          | awk '/mount -v/ { printf "if [ \"$(grep -q \""$NF"\" /proc/mounts;echo $?)\" != \"0\" ]; then\n  "$0"\nfi\n"}' \
          >> $Output
          Function
      ;;
      createfiles)
          Function
          # Now have a base file structure so add pkguser
          if ! $as_root; then
            pkguser
          else
            copypkguserbin # add listpkg only.
          fi
      ;;
      expect)
          SrcName=expect5
          Function
      ;;
      fstab) # can't deal with this here
          continue
      ;;
      introduction|toolchaintechnotes|generalinstructions|pkgmgt|aboutdebug)
      continue
      ;;
      libcap)
          SrcName=libcap2_
          Function
      ;;
      libstdc++)
          SrcName=gcc-
          Function
      ;;
      linux-headers|kernel)
          SrcName=linux-
          Function
      ;;
      perl) # if systemd and chapter06, need to install xml-parser
          if [[ "$Chapter" == chapter06 && "$SYSTEMD" == yes ]]; then
            Function
            FuncName=xmlparser
            PkgName=xml-parser
            SrcName=XML-Parser-
            CmdName=perl
            Function
          else
            Function
          fi
      ;;
      pkgconfig)
          PkgName=pkg-config
          CmdName=pkg-config
          SrcName=pkg-config-
          Function
      ;;
      procps)
          CmdName=procps-ng
          SrcName=procps-ng-
          Function
      ;;
      revisedchroot)
          Output=~/LFS-chroot.sh
          # use this once LFS chapter06 is done, again conditionals added
          cat $LFS/${Chapter}-asroot.sh \
          | awk '/mount -v/ {printf "if [ \"$(grep -q \""$NF"\" /proc/mounts;echo $?)\" != \"0\" ]; then\n  "$0"\nfi\n"}' \
          >> $Output
          WriteScript
      ;;
      tcl)
          SrcName=tcl8
          Function
      ;;
      xz)
          CmdName=xz-utils
          Function
      ;;
      *)
          if [[ "$Chapter" == chapter08 && "$PkgName" == grub ]]; then #want the grub in chapter06 but not the one in chapter08
            continue
          else
            Function
          fi
      ;;
    esac
  done
done
#
tempfile=/tmp/$(date +%d%B%Y_%H:%M)tmp.file
for eachScript in $LFS/chapter{05,06,08,06-asroot,06-chroot} ~/LFS-chroot
do
  Output=${eachScript}.sh
# match the start line for each function and output it
  awk '/_\ \(\)\ \{/ {print $1}' $Output >> $tempfile #write to a temp file
#
# you have an opportunity to reset the function order here
#
  while read eachFunc; do
#
# move check later in the build order because it failed to compile in the orig position
#    if [ "$eachFunc" = check_ ]; then # put check later because it fails at the moment
#      continue # don't write it yet
#    elif [ "$eachFunc" = stripping_ ]; then # write check here
#      echo check_ >> $Output
#      echo $eachFunc >> $Output
#    else
#      echo $eachFunc >> $Output
#    fi
# check is fine now so commented out the re-positioning
#
      echo $eachFunc >> $Output
  done < $tempfile
  rm $tempfile
  chmod 700 $Output
done
sed -e 's@BuildLog='$LFS'@BuildLog=@' -i $LFS/{chapter06.sh,chapter08.sh}
# remove all make checks from chapter05
sed -e '/make check/d' \
    -e '/make -j1 check/d' \
    -e '/make RUN_EXPENSIVE_TESTS=yes check/d' \
    -e '/TZ=UTC make test/d' \
    -e '/make test/d' \
    -i $LFS/chapter05.sh
#check if tests requested for chapter06
if [ $TESTS = "no" ]; then
  sed -e '/cp -v ..\/glibc-2.14.1\/iconvdata\/gconv-modules iconvdata/d' \
      -e '/make -k check 2>&1 | tee glibc-check-log/d' \
      -e '/grep Error glibc-check-log/d' \
      -e '/make check/d' \
      -e '/make -j1 check/d' \
      -e '/make -k check/d' \
      -e '/make -kj1 check/d' \
      -e '/make -k -j1 check/d' \
      -e '/make check 2>&1 | tee gmp-check-log/d' \
      -e "/awk '\/tests passed\/{total+=\$2} ; END{print total}' gmp-check-log/d" \
      -e '/make NON_ROOT_USERNAME=nobody check-root/d' \
      -e '/echo "dummy:x:1000:nobody" >> \/etc\/group/d' \
      -e '/chown -Rv nobody ./d' \
      -e '/su-tools nobody -s \/bin\/bash -c \"make RUN_EXPENSIVE_TESTS=yes check\"/d' \
      -e '/su-tools nobody -s \/bin\/bash -c "make tests"/d' \
      -e "/sed -i '\/dummy\/d' \/etc\/group/d" \
      -e '/make test/d' \
      -e '/make -k test/d' \
      -e '/make -j1 test/d' \
      -i $LFS/chapter06.sh
#remove making all the locales in glibc as the required ones have been installed
  sed -e '/make localedata\/install-locales/d' \
      -i $LFS/chapter06.sh
fi
#
# set lfs as owner of chapter05.sh
chown lfs $LFS/chapter05.sh
# create the build dir for chapter05.sh and set owner to lfs
if [ ! -d ${LFS}${builddir05} ]; then
  mkdir -pv ${LFS}${builddir05}
  chown lfs ${LFS}${builddir05}
else
  chown lfs ${LFS}${builddir05}
fi
} # end Start
#
# main program  - call the functions
#
if $display_menu; then
  configEdit # option to change the config file
  source $cfg # maybe config edited - update the values
fi
#
as_root=false
if [ "$AS_ROOT" = yes ]; then as_root=true; fi
#
# get the book
#
bookDir=$LFS_BOOK_LOC_DIR
if [ "$SYSTEMD" = yes ]; then bookDir=${bookDir}/SYSTEMD; fi
#
if [ "$BOOK" = svn ]; then
  if [[ "$SYSTEMD" == yes && "$BOOK_VERSION" != BOOK ]]; then
    echo "You have incompatible values set - "
    echo "You have SYSTEMD=yes but you have requested book $BOOK_VERSION"
    echo "If you want that book, set SYSTEMD=no"
    echo "If you want SYSTEMD=yes, set BOOK_VERSION=BOOK in the config file"
    exit 1
  fi
  GetSvnUrl # make sure the svn url is set
  if [ $BOOK_VERSION != "blank" ]; then #check if the requested book is present locally
    ChkLocalBook $bookDir
    SetLFSBook
  else #version set to blank so ask for which book
    WhichLFSBook # choose which LFS version to download the xml files
    # check if the requested book is already present locally
    ChkLocalBook $bookDir
  fi
  CleanLocalREPO $bookDir
  CheckoutSVN $bookDir # svn the requested book xml files
else  # local book
  ChkLocalBookExists $bookDir
  return_val=$?
  if [ "$return_val" -eq $RETURN_PARAM ]; then #no local book found
    echo "The requested book was not found at $bookDir/"
    echo "Change the location or svn it. Exiting now"
    exit 1
  else
    LocalBook  # set values for locally stored book xml
  fi
fi
DumpCommands $REPO $bookDir #parse the LFS xml
#
# get the sources
#
version=${version%/} # remove any trailing /
SourceDir=${SOURCEDIR}/${version}
sourceloc=${sourcedir}/${version} # location wrt lfs system
WgetList=${SourceDir}/${wgetlist}
if [ "$SYSTEMD" = yes ]; then
  SourceDir=${SOURCEDIR}/SYSTEMD/${version}
  sourceloc=${sourcedir}/SYSTEMD/${version} # wrt to lfs system
  WgetList=${SourceDir}/${wgetlist}
fi
if [ $SOURCES = "download" ]; then
  CleanSourceDir $SourceDir $WgetList # clean the sources file if not empty
  GetSource $version $SourceDir $WgetList $bookDir # download all the sources
fi
if [ ! -e $WgetList ]; then
  echo "No $wgetlist file present in $SourceDir"
  echo "Won't be able to check if sources exist"
else
  ChkSrcPresent $SourceDir $WgetList # check for src files present
  ret_val=$?
  if [ $ret_val -eq $RETURN_PARAM ]; then 
    echo "Not all requested files in $WgetList have been downloaded"
    echo "You will have to download the missing one(s) and place them in $SourceDir"
    echo "Do you wish to continue? (Y/n)"
    read reply
    case $reply in
      [yY]|[yY][Ee][Ss])
        echo "okay continue"
      ;;        
      [nN]|[nN][Oo])
        echo "Exiting now"
        exit 1
      ;;        
      *)   
        echo "okay continue"
      ;;        
    esac
  fi
  ChkEmptySrcFiles $SourceDir #check for failed downloads
  return_val=$?
  if [ "$return_val" -eq $RETURN_PARAM ]; then
    echo "Empty source files found in $SourceDir"
    echo "Exiting now"
    exit 1
  fi
fi
# get the required package versions
rtrvers=""
GetPkgVersion $SourceDir perl- tar
perlvers=$rtrvers
echo "will install perl version $perlvers"
rtrvers=""
GetPkgVersion $SourceDir systemd- tar
systemdvers=$rtrvers
echo "systemd version is $systemdveirs"
rtrvers=""
GetPkgVersion $SourceDir gettext- tar
gettextvers=$rtrvers
echo "gettext is version $gettextvers"
#
pkguserFile=$PKGUSERFILE
if [ -e ${LFS}${sourcedir}/${pkguserFile} ]; then
  unpackpkguser
else
  echo "Package user file $pkguserFile not found in ${LFS}${sourcedir}"
  echo "Please place it there in order to continue"
  echo "Exiting now"
  exit 1
fi
if [ ! -e $WgetList ];then
  echo "$WgetList file doesn't exist"
  echo "Won't be able to check the kernel version downloaded"
else
  GetLinuxVersion $SourceDir $WgetList # may have downloaded a later version than that in the book
fi
Start $bookDir # build the scripts
